// Generated by Haxe 4.3.0-rc.1+5f599ba
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var cornerContour_Contour = function(pen_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.count = 0;
	this.pointsAnti = [];
	this.pointsClock = [];
	this.pen = pen_;
	this.endLine = endLine_;
};
cornerContour_Contour.__name__ = true;
cornerContour_Contour.prototype = {
	reset: function() {
		this.angleA = 0;
		this.count = 0;
		this.kax = 0;
		this.kay = 0;
		this.kbx = 0;
		this.kby = 0;
		this.kcx = 0;
		this.kcy = 0;
		this.ncx = 0;
		this.ncy = 0;
		this.ax = 0;
		this.ay = 0;
		this.bx = 0;
		this.by = 0;
		this.cx = 0;
		this.cy = 0;
		this.dx = null;
		this.dy = null;
		this.ex = null;
		this.ey = null;
		this.pointsClock.length = 0;
		this.pointsAnti.length = 0;
	}
	,triangleJoin: function(ax_,ay_,bx_,by_,width_,curveEnds,overlap) {
		if(overlap == null) {
			overlap = false;
		}
		if(curveEnds == null) {
			curveEnds = false;
		}
		var oldAngle = this.dx != null ? this.angle1 : null;
		this.halfA = Math.PI / 2;
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var x = this.dxOld - bx_;
		var y = this.dyOld - by_;
		var x1 = this.exOld - bx_;
		var y1 = this.eyOld - by_;
		var clockWise = x * x + y * y > x1 * x1 + y1 * y1;
		var theta0;
		var theta1;
		if(clockWise) {
			theta0 = -Math.atan2(this.ay - this.dyOld,this.ax - this.dxOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.eyPrev,this.ax - this.exPrev) - Math.PI / 2;
		} else {
			theta0 = -Math.atan2(this.ay - this.eyOld,this.ax - this.exOld) - Math.PI / 2;
			theta1 = -Math.atan2(this.ay - this.dyPrev,this.ax - this.dxPrev) - Math.PI / 2;
		}
		var dif;
		switch(fracs_DifferencePreference.SMALL._hx_index) {
		case 0:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
			break;
		case 1:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
			break;
		case 2:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var smallest = theta <= Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		case 3:
			var f;
			if(theta0 >= 0 && theta0 > Math.PI) {
				f = theta0;
			} else {
				var a = theta0 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var za = this1;
			var f;
			if(theta1 >= 0 && theta1 > Math.PI) {
				f = theta1;
			} else {
				var a = theta1 % (2 * Math.PI);
				f = a >= 0 ? a : a + 2 * Math.PI;
			}
			var this1 = f;
			var zb = this1;
			var fa = za;
			var fb = zb;
			var theta = Math.abs(fa - fb);
			var largest = theta > Math.PI;
			var clockwise = fa < fb;
			var dif1 = clockwise ? theta : -theta;
			dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
			break;
		}
		if(!overlap && this.count != 0) {
			var gamma = Math.abs(dif) / 2;
			var h = width_ / 2 / Math.cos(gamma);
			var f;
			if(theta0 <= Math.PI && theta0 > -Math.PI) {
				f = theta0;
			} else {
				var a = (theta0 + Math.PI) % (2 * Math.PI);
				f = a >= 0 ? a - Math.PI : a + Math.PI;
			}
			var this1 = f;
			var start = this1;
			var start2 = start;
			var delta = start2 + dif / 2 + Math.PI;
			this.jx = this.ax + h * Math.sin(delta);
			this.jy = this.ay + h * Math.cos(delta);
		}
		if(this.count == 0 && (this.endLine == 1 || this.endLine == 3)) {
			var ax = this.ax;
			var ay = this.ay;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var temp = [];
			var color = -1;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif1;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 > 0 ? dif2 : 2 * Math.PI + dif2;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = dif2 < 0 ? dif2 : -2 * Math.PI + dif2;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = smallest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif2 = clockwise ? theta : -theta;
				dif1 = largest ? dif2 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif1 >= 0;
			var totalSteps = Math.ceil(Math.abs(dif1) / step);
			var step = dif1 / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var p4 = temp.length / 4 | 0;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[len - 2 * i + 1];
				this.pointsAnti[pA++] = temp[len - 2 * i];
			}
			var pC = this.pointsClock.length;
			var _g = 0;
			var _g1 = p4;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[i * 2 + len + 1];
				this.pointsClock[pC++] = temp[i * 2 + len];
			}
		}
		if(overlap) {
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
			this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
		} else {
			if(this.count != 0) {
				this.addQuads(clockWise,width_);
			}
			this.quadIndex = this.pen.get_pos();
			if(this.count == 0) {
				this.penultimateAX = this.dxPrev;
				this.penultimateAY = this.dyPrev;
				this.lastAntiX = this.ex;
				this.lastAntiY = this.ey;
				this.penultimateCX = this.dx;
				this.penultimateCY = this.dy;
				this.lastClockX = this.exPrev;
				this.lastClockY = this.eyPrev;
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
			} else {
				if(clockWise && !this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(clockWise && this.lastClock) {
					this.penultimateAX = this.jx;
					this.penultimateAY = this.jy;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.exPrev;
					this.lastClockY = this.eyPrev;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.exPrev,this.eyPrev,-1);
				}
				if(!clockWise && !this.lastClock) {
					this.penultimateCX = this.dx;
					this.penultimateCY = this.dy;
					this.lastClockX = this.jx;
					this.lastClockY = this.jy;
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.jx,this.jy,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.dx,this.dy,this.ex,this.ey,-1);
				}
				if(!clockWise && this.lastClock) {
					this.penultimateAX = this.dxPrev;
					this.penultimateAY = this.dyPrev;
					this.lastAntiX = this.ex;
					this.lastAntiY = this.ey;
					this.penultimateCX = this.jx;
					this.penultimateCY = this.jy;
					this.lastClockX = this.dx;
					this.lastClockY = this.dy;
					this.pen.triangle2DFill(this.jx,this.jy,this.dx,this.dy,this.ex,this.ey,-1);
					this.pen.triangle2DFill(this.dxPrev,this.dyPrev,this.jx,this.jy,this.ex,this.ey,-1);
				}
			}
		}
		if(curveEnds) {
			if(clockWise) {
				var radius = width_ / 2;
				var edgePoly = this.pointsClock;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			} else {
				var radius = width_ / 2;
				var edgePoly = this.pointsAnti;
				var pi = Math.PI;
				var step = pi * 2 / 36;
				var positive = dif >= 0;
				var totalSteps = Math.ceil(Math.abs(dif) / step);
				var step = dif / totalSteps;
				var angle = theta0;
				var cx;
				var cy;
				var bx = 0;
				var by = 0;
				var p2 = edgePoly.length;
				var _g = 0;
				var _g1 = totalSteps + 1;
				while(_g < _g1) {
					var i = _g++;
					cx = ax_ + radius * Math.sin(angle);
					cy = ay_ + radius * Math.cos(angle);
					edgePoly[p2++] = cx;
					edgePoly[p2++] = cy;
					if(i != 0) {
						var color_ = -1;
						if(color_ == null) {
							color_ = -1;
						}
						this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
					}
					angle += step;
					bx = cx;
					by = cy;
				}
			}
		} else if(this.count != 0) {
			if(overlap) {
				if(clockWise) {
					this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.ax,this.ay,-1);
				} else {
					this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.ax,this.ay,-1);
				}
			} else if(clockWise) {
				this.pen.triangle2DFill(this.dxOld,this.dyOld,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.exOld,this.eyOld,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.kax = this.dxPrev;
		this.kay = this.dyPrev;
		this.kbx = this.dx;
		this.kby = this.dy;
		this.ncx = this.exPrev;
		this.ncy = this.eyPrev;
		this.kcx = this.ex;
		this.kcy = this.ey;
		if(curveEnds && !overlap && this.count != 0) {
			if(clockWise) {
				this.pen.triangle2DFill(this.ax,this.ay,this.dxOld,this.dyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.exPrev,this.eyPrev,this.jx,this.jy,-1);
			} else {
				this.pen.triangle2DFill(this.ax,this.ay,this.exOld,this.eyOld,this.jx,this.jy,-1);
				this.pen.triangle2DFill(this.ax,this.ay,this.dxPrev,this.dyPrev,this.jx,this.jy,-1);
			}
		}
		this.jxOld = this.jx;
		this.jyOld = this.jy;
		this.lastClock = clockWise;
		this.count++;
	}
	,end: function(width_) {
		this.endEdges();
		if(this.count != 0) {
			var ax = this.bx;
			var ay = this.by;
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var temp = [];
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var p2 = temp.length;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax + radius * Math.sin(angle);
				cy = ay + radius * Math.cos(angle);
				temp[p2++] = cx;
				temp[p2++] = cy;
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax,ay,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var pA = this.pointsAnti.length;
			var len = temp.length / 2 | 0;
			var _g = 0;
			var _g1 = len + 2;
			while(_g < _g1) {
				var i = _g++;
				this.pointsAnti[pA++] = temp[i];
			}
			var pC = this.pointsClock.length;
			var _g = 1;
			var _g1 = len / 2 + 1 | 0;
			while(_g < _g1) {
				var i = _g++;
				this.pointsClock[pC++] = temp[temp.length - 2 * i];
				this.pointsClock[pC++] = temp[temp.length - 2 * i - 1];
			}
		}
	}
	,endEdges: function() {
		var pC = this.pointsClock.length;
		var pA = this.pointsAnti.length;
		this.pointsClock[pC++] = this.penultimateCX;
		this.pointsClock[pC++] = this.penultimateCY;
		this.pointsClock[pC++] = this.lastClockX;
		this.pointsClock[pC++] = this.lastClockY;
		this.pointsAnti[pA++] = this.penultimateAX;
		this.pointsAnti[pA++] = this.penultimateAY;
		this.pointsAnti[pA++] = this.lastAntiX;
		this.pointsAnti[pA++] = this.lastAntiY;
	}
	,addQuads: function(clockWise,width_) {
		var currQuadIndex = this.pen.get_pos();
		var pC = 0;
		var pA = 0;
		if(clockWise && !this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jxOld,this.jyOld,-1);
			}
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
		}
		if(clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				this.pointsAnti[pA++] = this.kbx;
				this.pointsAnti[pA++] = this.kby;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.kax;
				this.pointsClock[pC++] = this.kay;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.kbx,this.kby,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.jx;
				this.pointsAnti[pA++] = this.jy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.kbx;
				this.pointsClock[pC++] = this.kby;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.jx,this.jy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.kbx,this.kby,this.ncx,this.ncy,-1);
			}
		}
		if(!clockWise && !this.lastClock) {
			this.pen.set_pos(this.quadIndex);
			this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jxOld;
				this.pointsClock[pC++] = this.jyOld;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.jxOld,this.jyOld,-1);
			}
		}
		if(!clockWise && this.lastClock) {
			if(this.count == 1) {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.kay;
				this.pointsAnti[pA++] = this.kax;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.kax,this.kay,this.jx,this.jy,this.ncx,this.ncy,-1);
			} else {
				pA = this.pointsAnti.length;
				this.pointsAnti[pA++] = this.jxOld;
				this.pointsAnti[pA++] = this.jyOld;
				this.pointsAnti[pA++] = this.kcx;
				this.pointsAnti[pA++] = this.kcy;
				pC = this.pointsClock.length;
				this.pointsClock[pC++] = this.jx;
				this.pointsClock[pC++] = this.jy;
				this.pointsClock[pC++] = this.ncx;
				this.pointsClock[pC++] = this.ncy;
				this.pen.set_pos(this.quadIndex);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.kcx,this.kcy,-1);
				this.pen.set_pos(this.quadIndex + 1);
				this.pen.triangle2DFill(this.jxOld,this.jyOld,this.jx,this.jy,this.ncx,this.ncy,-1);
			}
		}
		this.pen.set_pos(currQuadIndex);
	}
	,line: function(ax_,ay_,bx_,by_,width_,endLineCurve) {
		if(endLineCurve == null) {
			endLineCurve = 0;
		}
		this.ax = bx_;
		this.ay = by_;
		this.bx = ax_;
		this.by = ay_;
		this.halfA = Math.PI / 2;
		this.beta = Math.PI / 2 - this.halfA;
		this.r = width_ / 2 * Math.cos(this.beta);
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		var dxPrev_ = this.dx;
		var dyPrev_ = this.dy;
		var exPrev_ = this.ex;
		var eyPrev_ = this.ey;
		this.ax = ax_;
		this.ay = ay_;
		this.bx = bx_;
		this.by = by_;
		this.theta = Math.atan2(this.ay - this.by,this.ax - this.bx);
		if(this.theta > 0) {
			if(this.halfA < 0) {
				this.angle2 = this.theta + this.halfA + Math.PI / 2;
				this.angle1 = this.theta - this.halfA;
			} else {
				this.angle1 = this.theta + this.halfA - Math.PI;
				this.angle2 = this.theta + this.halfA;
			}
		} else if(this.halfA > 0) {
			this.angle1 = this.theta + this.halfA - Math.PI;
			this.angle2 = this.theta + this.halfA;
		} else {
			this.angle2 = this.theta + this.halfA + Math.PI / 2;
			this.angle1 = this.theta - this.halfA;
		}
		if(this.dxPrev != null) {
			this.dxOld = this.dxPrev;
		}
		if(this.dyPrev != null) {
			this.dyOld = this.dyPrev;
		}
		if(this.exPrev != null) {
			this.exOld = this.exPrev;
		}
		if(this.eyPrev != null) {
			this.eyOld = this.eyPrev;
		}
		if(this.dx != null) {
			this.dxPrev = this.dx;
		}
		if(this.dy != null) {
			this.dyPrev = this.dy;
		}
		if(this.ex != null) {
			this.exPrev = this.ex;
		}
		if(this.ey != null) {
			this.eyPrev = this.ey;
		}
		this.dx = this.bx + this.r * Math.cos(this.angle1);
		this.dy = this.by + this.r * Math.sin(this.angle1);
		this.ex = this.bx + this.r * Math.cos(this.angle2);
		this.ey = this.by + this.r * Math.sin(this.angle2);
		switch(endLineCurve) {
		case 0:
			break;
		case 1:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 2:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		case 3:
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 + Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = ax_ + radius * Math.sin(angle);
				cy = ay_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(ax_,ay_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			var radius = width_ / 2;
			var beta = -this.angle1 - Math.PI / 2;
			var gamma = -this.angle1 - Math.PI / 2 - Math.PI;
			var color = 0;
			var sides = 36;
			if(sides == null) {
				sides = 36;
			}
			if(color == null) {
				color = -1;
			}
			var pi = Math.PI;
			var step = pi * 2 / sides;
			var dif;
			switch(fracs_DifferencePreference.SMALL._hx_index) {
			case 0:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 > 0 ? dif1 : 2 * Math.PI + dif1;
				break;
			case 1:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = dif1 < 0 ? dif1 : -2 * Math.PI + dif1;
				break;
			case 2:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var smallest = theta <= Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = smallest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			case 3:
				var f;
				if(beta >= 0 && beta > Math.PI) {
					f = beta;
				} else {
					var a = beta % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var za = this1;
				var f;
				if(gamma >= 0 && gamma > Math.PI) {
					f = gamma;
				} else {
					var a = gamma % (2 * Math.PI);
					f = a >= 0 ? a : a + 2 * Math.PI;
				}
				var this1 = f;
				var zb = this1;
				var fa = za;
				var fb = zb;
				var theta = Math.abs(fa - fb);
				var largest = theta > Math.PI;
				var clockwise = fa < fb;
				var dif1 = clockwise ? theta : -theta;
				dif = largest ? dif1 : clockwise ? -(2 * Math.PI - theta) : 2 * Math.PI - theta;
				break;
			}
			var positive = dif >= 0;
			var totalSteps = Math.ceil(Math.abs(dif) / step);
			var step = dif / totalSteps;
			var angle = beta;
			var cx;
			var cy;
			var bx = 0;
			var by = 0;
			var _g = 0;
			var _g1 = totalSteps + 1;
			while(_g < _g1) {
				var i = _g++;
				cx = bx_ + radius * Math.sin(angle);
				cy = by_ + radius * Math.cos(angle);
				if(i != 0) {
					var color_ = color;
					if(color_ == null) {
						color_ = -1;
					}
					this.pen.triangle2DFill(bx_,by_,bx,by,cx,cy,color_);
				}
				angle += step;
				bx = cx;
				by = cy;
			}
			break;
		}
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,exPrev_,eyPrev_,-1);
		this.pen.triangle2DFill(dxPrev_,dyPrev_,this.dx,this.dy,this.ex,this.ey,-1);
	}
};
var cornerContour_Pen2D = function(col) {
	var this1 = [];
	this1[0] = 0.;
	this.arr = this1;
	this.currentColor = col;
};
cornerContour_Pen2D.__name__ = true;
cornerContour_Pen2D.prototype = {
	get_pos: function() {
		return this.arr[0];
	}
	,set_pos: function(val) {
		this.arr[0] = val;
		return val;
	}
	,triangle2DFill: function(ax,ay,bx,by,cx,cy,color) {
		if(color == null || color == -1) {
			color = this.currentColor;
		}
		var this1 = this.arr;
		cornerContour_io_Array2DTriangles.triangle(this1,ax,ay,bx,by,cx,cy);
		if(color == null) {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,16711680);
		} else {
			cornerContour_io_Array2DTriangles.set_colorInt(this1,color);
		}
		var pos_ = this.arr[0] + 1;
		this.arr[0] = pos_;
		return 1;
	}
};
var cornerContour_Sketcher = function(pen_,sketchForm_,endLine_) {
	if(endLine_ == null) {
		endLine_ = 0;
	}
	this.historyParameters = [];
	this.historyCommands = [];
	this.historyParamPos = [];
	this.turtleParameters = [];
	this.turtleCommands = [];
	this.repeatCommands = false;
	this.repeatCount = 0;
	this.fill = false;
	this.lastDistance = 0.;
	this.rotation = 0.;
	this.penIsDown = true;
	this.width = 0.01;
	this.y = 0.;
	this.x = 0.;
	this.rotation = -Math.PI / 2;
	this.pen = pen_;
	this.endLine = endLine_;
	this.contour = this.createContour();
	this.sketchForm = sketchForm_;
	switch(sketchForm_) {
	case 0:
		this.line = $bind(this,this.tracerLine);
		break;
	case 1:
		this.line = $bind(this,this.baseLine);
		break;
	case 2:
		this.line = $bind(this,this.crudeLine);
		break;
	case 3:
		this.line = $bind(this,this.fillOnlyLine);
		break;
	case 4:
		this.line = $bind(this,this.fineLine);
		break;
	case 5:
		this.line = $bind(this,this.fineOverlapLine);
		break;
	case 6:
		this.line = $bind(this,this.mediumLine);
		break;
	case 7:
		this.line = $bind(this,this.mediumOverlapLine);
		break;
	case 8:
		this.line = $bind(this,this.roundEndLine);
		break;
	}
	this.points = [];
	this.pointsClock = [];
	this.pointsAnti = [];
	this.points[0] = [];
	this.dim = [];
};
cornerContour_Sketcher.__name__ = true;
cornerContour_Sketcher.prototype = {
	tracerLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 30, className : "cornerContour.Sketcher", methodName : "tracerLine"});
	}
	,fillOnlyLine: function(x_,y_) {
	}
	,baseLine: function(x_,y_) {
		haxe_Log.trace("lineTo( " + this.x + ", " + this.y + ", " + x_ + ", " + y_ + ", width )",{ fileName : "cornerContour/Sketcher.hx", lineNumber : 30, className : "cornerContour.Sketcher", methodName : "tracerLine"});
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,crudeLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width);
	}
	,roundEndLine: function(x_,y_) {
		this.contour.line(this.x,this.y,x_,y_,this.width,3);
	}
	,mediumLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false);
	}
	,mediumOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,false,true);
	}
	,fineLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true);
	}
	,fineOverlapLine: function(x_,y_) {
		this.contour.triangleJoin(this.x,this.y,x_,y_,this.width,true,true);
	}
	,createContour: function() {
		return new cornerContour_Contour(this.pen,this.endLine);
	}
	,lineTo: function(x_,y_) {
		var repeat = this.x == x_ && this.y == y_;
		if(!repeat) {
			if(this.widthFunction != null) {
				this.width = this.widthFunction(this.width,this.x,this.y,x_,y_);
			}
			if(this.colourFunction != null) {
				this.pen.currentColor = this.colourFunction(this.pen.currentColor,this.x,this.y,x_,y_);
			}
			this.line(x_,y_);
			var l = this.points.length;
			var p = this.points[l - 1];
			var l2 = p.length;
			p[l2] = x_;
			p[l2 + 1] = y_;
			var d = this.dim[this.dim.length - 1];
			if(x_ < d.minX) {
				d.minX = x_;
			}
			if(x_ > d.maxX) {
				d.maxX = x_;
			}
			if(y_ < d.minY) {
				d.minY = y_;
			}
			if(y_ > d.maxY) {
				d.maxY = y_;
			}
			this.x = x_;
			this.y = y_;
		}
	}
	,historyAdd: function(command) {
		this.historyParamPos.push(this.historyParameters.length);
		this.historyCommands.push(command);
		return this.historyParameters.length;
	}
};
var cornerContour_io_Array2DTriangles = {};
cornerContour_io_Array2DTriangles.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1];
};
cornerContour_io_Array2DTriangles.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 7 + 1 + 1];
};
cornerContour_io_Array2DTriangles.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 1 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 2 + 1];
};
cornerContour_io_Array2DTriangles.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 2 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_by = function(this1) {
	return this1[(this1[0] | 0) * 7 + 3 + 1];
};
cornerContour_io_Array2DTriangles.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 3 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 7 + 4 + 1];
};
cornerContour_io_Array2DTriangles.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 4 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 7 + 5 + 1];
};
cornerContour_io_Array2DTriangles.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 7 + 5 + 1] = v;
	return v;
};
cornerContour_io_Array2DTriangles.get_color = function(this1) {
	return this1[(this1[0] | 0) * 7 + 6 + 1];
};
cornerContour_io_Array2DTriangles.set_colorInt = function(this1,v) {
	var v1 = v | 0;
	this1[(this1[0] | 0) * 7 + 6 + 1] = v1;
	return v;
};
cornerContour_io_Array2DTriangles.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
	cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
	cornerContour_io_Array2DTriangles.set_bx(this1,bx_);
	cornerContour_io_Array2DTriangles.set_by(this1,by_);
	cornerContour_io_Array2DTriangles.set_cx(this1,cx_);
	cornerContour_io_Array2DTriangles.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_Array2DTriangles.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_Array2DTriangles.set_ax(this1,ax_);
		cornerContour_io_Array2DTriangles.set_ay(this1,ay_);
		cornerContour_io_Array2DTriangles.set_bx(this1,cx_);
		cornerContour_io_Array2DTriangles.set_by(this1,cy_);
		cornerContour_io_Array2DTriangles.set_cx(this1,bx_);
		cornerContour_io_Array2DTriangles.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_Array2DTriangles.adjustWinding = function(this1) {
	return cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_by(this1) - cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) + (cornerContour_io_Array2DTriangles.get_bx(this1) * cornerContour_io_Array2DTriangles.get_cy(this1) - cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_by(this1)) + (cornerContour_io_Array2DTriangles.get_cx(this1) * cornerContour_io_Array2DTriangles.get_ay(this1) - cornerContour_io_Array2DTriangles.get_ax(this1) * cornerContour_io_Array2DTriangles.get_cy(this1)) > 0;
};
var cornerContour_io_ColorTriangles2D = {};
cornerContour_io_ColorTriangles2D.get_ax = function(this1) {
	return this1[(this1[0] | 0) * 18 + 2];
};
cornerContour_io_ColorTriangles2D.set_ax = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_ay = function(this1) {
	return this1[(this1[0] | 0) * 18 + 1 + 2];
};
cornerContour_io_ColorTriangles2D.set_ay = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 1 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.set_redA = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 2 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_bx = function(this1) {
	return this1[(this1[0] | 0) * 18 + 6 + 2];
};
cornerContour_io_ColorTriangles2D.set_bx = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 6 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_by = function(this1) {
	return this1[(this1[0] | 0) * 18 + 7 + 2];
};
cornerContour_io_ColorTriangles2D.set_by = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 7 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.set_redB = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 8 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_cx = function(this1) {
	return this1[(this1[0] | 0) * 18 + 12 + 2];
};
cornerContour_io_ColorTriangles2D.set_cx = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 12 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.get_cy = function(this1) {
	return this1[(this1[0] | 0) * 18 + 13 + 2];
};
cornerContour_io_ColorTriangles2D.set_cy = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 13 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.set_redC = function(this1,v) {
	this1[(this1[0] | 0) * 18 + 14 + 2] = v;
	return v;
};
cornerContour_io_ColorTriangles2D.triangle = function(this1,ax_,ay_,bx_,by_,cx_,cy_) {
	cornerContour_io_ColorTriangles2D.set_ax(this1,ax_);
	cornerContour_io_ColorTriangles2D.set_ay(this1,ay_);
	cornerContour_io_ColorTriangles2D.set_bx(this1,bx_);
	cornerContour_io_ColorTriangles2D.set_by(this1,by_);
	cornerContour_io_ColorTriangles2D.set_cx(this1,cx_);
	cornerContour_io_ColorTriangles2D.set_cy(this1,cy_);
	var windingAdjusted = cornerContour_io_ColorTriangles2D.adjustWinding(this1);
	if(windingAdjusted) {
		cornerContour_io_ColorTriangles2D.set_ax(this1,ax_);
		cornerContour_io_ColorTriangles2D.set_ay(this1,ay_);
		cornerContour_io_ColorTriangles2D.set_bx(this1,cx_);
		cornerContour_io_ColorTriangles2D.set_by(this1,cy_);
		cornerContour_io_ColorTriangles2D.set_cx(this1,bx_);
		cornerContour_io_ColorTriangles2D.set_cy(this1,by_);
	}
	return windingAdjusted;
};
cornerContour_io_ColorTriangles2D.adjustWinding = function(this1) {
	return cornerContour_io_ColorTriangles2D.get_ax(this1) * cornerContour_io_ColorTriangles2D.get_by(this1) - cornerContour_io_ColorTriangles2D.get_bx(this1) * cornerContour_io_ColorTriangles2D.get_ay(this1) + (cornerContour_io_ColorTriangles2D.get_bx(this1) * cornerContour_io_ColorTriangles2D.get_cy(this1) - cornerContour_io_ColorTriangles2D.get_cx(this1) * cornerContour_io_ColorTriangles2D.get_by(this1)) + (cornerContour_io_ColorTriangles2D.get_cx(this1) * cornerContour_io_ColorTriangles2D.get_ay(this1) - cornerContour_io_ColorTriangles2D.get_ax(this1) * cornerContour_io_ColorTriangles2D.get_cy(this1)) > 0;
};
var cornerContour_io_IntIterStart = function(min_,max_) {
	this.start = min_;
	this.max = max_;
};
cornerContour_io_IntIterStart.__name__ = true;
var cornerContourWebGLTest_CornerContourWebGL2 = function() {
	this.theta = 0.;
	this.allRange = [];
	this.toggle = true;
	this.speed = 0.055;
	this.count = 0;
	this.vertexColor = "vertexColor";
	this.vertexPosition = "vertexPosition";
	this.divertTrace = new cornerContourWebGLTest_DivertTrace();
	haxe_Log.trace("Contour Test",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL2.js.hx", lineNumber : 62, className : "cornerContourWebGLTest.CornerContourWebGL2", methodName : "new"});
	this.width = 1024;
	this.height = 768;
	this.mainSheet = new cornerContourWebGLTest_Sheet();
	this.mainSheet.create(this.width,this.height,true);
	this.gl = this.mainSheet.gl;
	this.drawContours();
	this.rearrageDrawData();
	var gl = this.gl;
	var program = gl.createProgram();
	var shader = gl.createShader(35633);
	gl.shaderSource(shader,"attribute vec2 vertexPosition;" + "attribute vec4 vertexColor;" + "varying vec4 vcol;" + "void main(void) {" + " gl_Position = vec4(vertexPosition, .0, 1.0);" + " vcol = vertexColor;" + "}");
	gl.compileShader(shader);
	var tmp;
	if(!gl.getShaderParameter(shader,35713)) {
		throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
	} else {
		tmp = shader;
	}
	gl.attachShader(program,tmp);
	var shader = gl.createShader(35632);
	gl.shaderSource(shader,"precision mediump float;" + "varying vec4 vcol;" + "void main(void) {" + "vec4 color = vec4(vcol.rgb, 1. );" + "color *= vcol.a; " + "gl_FragColor = color;" + "}");
	gl.compileShader(shader);
	var tmp;
	if(!gl.getShaderParameter(shader,35713)) {
		throw haxe_Exception.thrown("Error compiling shader. " + gl.getShaderInfoLog(shader));
	} else {
		tmp = shader;
	}
	gl.attachShader(program,tmp);
	gl.linkProgram(program);
	var tmp;
	if(!gl.getProgramParameter(program,35714)) {
		throw haxe_Exception.thrown("Error linking program. " + gl.getProgramInfoLog(program));
	} else {
		gl.validateProgram(program);
		if(!gl.getProgramParameter(program,35715)) {
			throw haxe_Exception.thrown("Error validating program. " + gl.getProgramInfoLog(program));
		} else {
			gl.useProgram(program);
			tmp = program;
		}
	}
	this.programColor = tmp;
	this.gl.bindBuffer(34962,null);
	this.gl.useProgram(this.programColor);
	var this1 = this.arrData;
	var arr = this1.subarray(2,(this1[1] | 0) * 18 + 2);
	var gl = this.gl;
	var program = this.programColor;
	var xyName = this.vertexPosition;
	var rgbaName = this.vertexColor;
	var isDynamic = true;
	if(isDynamic == null) {
		isDynamic = false;
	}
	var isDynamic1 = isDynamic;
	if(isDynamic1 == null) {
		isDynamic1 = false;
	}
	var buf = gl.createBuffer();
	var staticDraw = 35044;
	var dynamicDraw = 35048;
	var arrayBuffer = 34962;
	gl.bindBuffer(arrayBuffer,buf);
	if(isDynamic1) {
		var arrayBuffer = 34962;
		gl.bufferData(arrayBuffer,arr,dynamicDraw);
	} else {
		var arrayBuffer = 34962;
		gl.bufferData(arrayBuffer,arr,staticDraw);
	}
	var vbo = buf;
	var inp = gl.getAttribLocation(program,xyName);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 0 * elementBytes;
	gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	var inp = gl.getAttribLocation(program,rgbaName);
	var elementBytes = 4;
	var fp = 5126;
	var strideBytes = 6 * elementBytes;
	var offBytes = 2 * elementBytes;
	gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
	gl.enableVertexAttribArray(inp);
	this.bufColor = vbo;
	this.gl.bindBuffer(34962,this.bufColor);
	this.setProgramMode();
	var _gthis = this;
	if(htmlHelper_tools_AnimateTimer.s == null) {
		htmlHelper_tools_AnimateTimer.s = window.document.createElement("style");
		htmlHelper_tools_AnimateTimer.s.innerHTML = "@keyframes spin { from { transform:rotate( 0deg ); } to { transform:rotate( 360deg ); } }";
		window.document.getElementsByTagName("head")[0].appendChild(htmlHelper_tools_AnimateTimer.s);
		htmlHelper_tools_AnimateTimer.s.animation = "spin 1s linear infinite";
		htmlHelper_tools_AnimateTimer.loop(60.0);
	}
	htmlHelper_tools_AnimateTimer.onFrame = function(v) {
		var gl = _gthis.gl;
		var width = _gthis.width;
		var height = _gthis.height;
		var r = 0.;
		var g = 0.;
		var b = 0.;
		var a = 1.;
		if(a == null) {
			a = 0.;
		}
		if(b == null) {
			b = 0.;
		}
		if(g == null) {
			g = 0.;
		}
		if(r == null) {
			r = 0.;
		}
		gl.clearColor(r,g,b,a);
		gl.enable(2929);
		gl.clear(16384);
		gl.viewport(0,0,width,height);
		gl.enable(3042);
		gl.blendFunc(1,771);
		gl.enable(2884);
		var triSize = 18;
		var totalTriangles = (_gthis.pen2D.arr.length - 1) / 7 | 0;
		if(_gthis.toggle) {
			_gthis.count++;
		} else {
			_gthis.count--;
		}
		var l = _gthis.allRange.length;
		var allEnded = 0;
		var allStarted = 0;
		var _g = 0;
		var _g1 = l;
		while(_g < _g1) {
			var i = _g++;
			var range = _gthis.allRange[i];
			var addOn = _gthis.count * (range.max - range.start) / 100;
			var ending = range.start + Math.round(addOn * _gthis.speed) * triSize;
			if(ending > range.max - 1) {
				ending = range.max - 1;
				++allEnded;
			}
			if(ending < range.start) {
				ending = range.start;
				++allStarted;
			}
			switch(i) {
			case 0:
				var this1 = _gthis.arrData;
				var x = -(1 - 440 / _gthis.width);
				var y = 1 - 880 / _gthis.height;
				var theta = Math.PI / 100;
				var temp = this1[0];
				var _g_min = range.start;
				var _g_max = range.max;
				while(_g_min < _g_max) {
					var i1 = _g_min++;
					this1[0] = i1;
					if(this1[0] > this1[1] - 1) {
						this1[1] = this1[0];
					}
					var cos = Math.cos(theta);
					var sin = Math.sin(theta);
					cornerContour_io_ColorTriangles2D.set_ax(this1,cornerContour_io_ColorTriangles2D.get_ax(this1) - x);
					cornerContour_io_ColorTriangles2D.set_ay(this1,cornerContour_io_ColorTriangles2D.get_ay(this1) - y);
					cornerContour_io_ColorTriangles2D.set_bx(this1,cornerContour_io_ColorTriangles2D.get_bx(this1) - x);
					cornerContour_io_ColorTriangles2D.set_by(this1,cornerContour_io_ColorTriangles2D.get_by(this1) - y);
					cornerContour_io_ColorTriangles2D.set_cx(this1,cornerContour_io_ColorTriangles2D.get_cx(this1) - x);
					cornerContour_io_ColorTriangles2D.set_cy(this1,cornerContour_io_ColorTriangles2D.get_cy(this1) - y);
					var dx = cornerContour_io_ColorTriangles2D.get_ax(this1);
					var dy = cornerContour_io_ColorTriangles2D.get_ay(this1);
					cornerContour_io_ColorTriangles2D.set_ax(this1,dx * cos - dy * sin);
					cornerContour_io_ColorTriangles2D.set_ay(this1,dx * sin + dy * cos);
					dx = cornerContour_io_ColorTriangles2D.get_bx(this1);
					dy = cornerContour_io_ColorTriangles2D.get_by(this1);
					cornerContour_io_ColorTriangles2D.set_bx(this1,dx * cos - dy * sin);
					cornerContour_io_ColorTriangles2D.set_by(this1,dx * sin + dy * cos);
					dx = cornerContour_io_ColorTriangles2D.get_cx(this1);
					dy = cornerContour_io_ColorTriangles2D.get_cy(this1);
					cornerContour_io_ColorTriangles2D.set_cx(this1,dx * cos - dy * sin);
					cornerContour_io_ColorTriangles2D.set_cy(this1,dx * sin + dy * cos);
					cornerContour_io_ColorTriangles2D.set_ax(this1,cornerContour_io_ColorTriangles2D.get_ax(this1) + x);
					cornerContour_io_ColorTriangles2D.set_ay(this1,cornerContour_io_ColorTriangles2D.get_ay(this1) + y);
					cornerContour_io_ColorTriangles2D.set_bx(this1,cornerContour_io_ColorTriangles2D.get_bx(this1) + x);
					cornerContour_io_ColorTriangles2D.set_by(this1,cornerContour_io_ColorTriangles2D.get_by(this1) + y);
					cornerContour_io_ColorTriangles2D.set_cx(this1,cornerContour_io_ColorTriangles2D.get_cx(this1) + x);
					cornerContour_io_ColorTriangles2D.set_cy(this1,cornerContour_io_ColorTriangles2D.get_cy(this1) + y);
				}
				this1[0] = temp;
				if(this1[0] > this1[1] - 1) {
					this1[1] = this1[0];
				}
				break;
			case 1:
				var this2 = _gthis.arrData;
				var dx1 = 0.005 * Math.sin(_gthis.theta * _gthis.theta - Math.PI / 4);
				var dy1 = 0.005 * Math.sin(_gthis.theta - Math.PI / 8);
				var temp1 = this2[0];
				var _g_min1 = range.start;
				var _g_max1 = range.max;
				while(_g_min1 < _g_max1) {
					var i2 = _g_min1++;
					this2[0] = i2;
					if(this2[0] > this2[1] - 1) {
						this2[1] = this2[0];
					}
					cornerContour_io_ColorTriangles2D.set_ax(this2,cornerContour_io_ColorTriangles2D.get_ax(this2) + dx1);
					cornerContour_io_ColorTriangles2D.set_ay(this2,cornerContour_io_ColorTriangles2D.get_ay(this2) + dy1);
					cornerContour_io_ColorTriangles2D.set_bx(this2,cornerContour_io_ColorTriangles2D.get_bx(this2) + dx1);
					cornerContour_io_ColorTriangles2D.set_by(this2,cornerContour_io_ColorTriangles2D.get_by(this2) + dy1);
					cornerContour_io_ColorTriangles2D.set_cx(this2,cornerContour_io_ColorTriangles2D.get_cx(this2) + dx1);
					cornerContour_io_ColorTriangles2D.set_cy(this2,cornerContour_io_ColorTriangles2D.get_cy(this2) + dy1);
				}
				this2[0] = temp1;
				if(this2[0] > this2[1] - 1) {
					this2[1] = this2[0];
				}
				break;
			case 2:
				var this3 = _gthis.arrData;
				var a = 0.5 + 0.3 * Math.sin(_gthis.theta - Math.PI / 2);
				var temp2 = this3[0];
				var _g_min2 = range.start;
				var _g_max2 = range.max;
				while(_g_min2 < _g_max2) {
					var i3 = _g_min2++;
					this3[0] = i3;
					if(this3[0] > this3[1] - 1) {
						this3[1] = this3[0];
					}
					this3[(this3[0] | 0) * 18 + 5 + 2] = a;
					this3[(this3[0] | 0) * 18 + 11 + 2] = a;
					this3[(this3[0] | 0) * 18 + 17 + 2] = a;
				}
				this3[0] = temp2;
				if(this3[0] > this3[1] - 1) {
					this3[1] = this3[0];
				}
				break;
			}
			var this4 = _gthis.arrData;
			_gthis.drawData(_gthis.programColor,this4.subarray(2,(this4[1] | 0) * 18 + 2),range.start,ending,triSize);
			if(allEnded == 3) {
				_gthis.toggle = false;
			}
			if(allStarted == 3) {
				_gthis.toggle = true;
			}
		}
		_gthis.theta += 0.1;
	};
};
cornerContourWebGLTest_CornerContourWebGL2.__name__ = true;
cornerContourWebGLTest_CornerContourWebGL2.prototype = {
	rearrageDrawData: function() {
		haxe_Log.trace("rearrangeDrawData",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL2.js.hx", lineNumber : 84, className : "cornerContourWebGLTest.CornerContourWebGL2", methodName : "rearrageDrawData"});
		var pen = this.pen2D;
		var data = pen.arr;
		this.totalTriangles = (data.length - 1) / 7 | 0;
		this.bufferLength = this.totalTriangles * 3;
		this.len = this.totalTriangles * 6 * 3 | 0;
		var j = 0;
		var this1 = new Float32Array(this.len + 2);
		var this2 = this1;
		this2[0] = 0.;
		this2[1] = 0.;
		var this1 = this2;
		var this2 = this1;
		var this1 = this2;
		this.arrData = this1;
		var _g = 0;
		var _g1 = this.totalTriangles;
		while(_g < _g1) {
			var i = _g++;
			pen.arr[0] = i;
			var this1 = this.arrData;
			this1[0] = i;
			if(this1[0] > this1[1] - 1) {
				this1[1] = this1[0];
			}
			var this2 = this.arrData;
			var col = cornerContour_io_Array2DTriangles.get_color(data) | 0;
			cornerContour_io_ColorTriangles2D.set_redA(this2,(col >> 16 & 255) / 255);
			var v = (col & 255) / 255;
			this2[(this2[0] | 0) * 18 + 4 + 2] = v;
			var v1 = (col >> 8 & 255) / 255;
			this2[(this2[0] | 0) * 18 + 3 + 2] = v1;
			var v2 = (col >> 24 & 255) / 255;
			this2[(this2[0] | 0) * 18 + 5 + 2] = v2;
			cornerContour_io_ColorTriangles2D.set_redB(this2,(col >> 16 & 255) / 255);
			var v3 = (col & 255) / 255;
			this2[(this2[0] | 0) * 18 + 10 + 2] = v3;
			var v4 = (col >> 8 & 255) / 255;
			this2[(this2[0] | 0) * 18 + 9 + 2] = v4;
			var v5 = (col >> 24 & 255) / 255;
			this2[(this2[0] | 0) * 18 + 11 + 2] = v5;
			cornerContour_io_ColorTriangles2D.set_redC(this2,(col >> 16 & 255) / 255);
			var v6 = (col & 255) / 255;
			this2[(this2[0] | 0) * 18 + 16 + 2] = v6;
			var v7 = (col >> 8 & 255) / 255;
			this2[(this2[0] | 0) * 18 + 15 + 2] = v7;
			var v8 = (col >> 24 & 255) / 255;
			this2[(this2[0] | 0) * 18 + 17 + 2] = v8;
			cornerContour_io_ColorTriangles2D.set_ax(this.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_ax(data) / this.width));
			cornerContour_io_ColorTriangles2D.set_ay(this.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_ay(data) / this.height);
			cornerContour_io_ColorTriangles2D.set_bx(this.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_bx(data) / this.width));
			cornerContour_io_ColorTriangles2D.set_by(this.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_by(data) / this.height);
			cornerContour_io_ColorTriangles2D.set_cx(this.arrData,-(1 - 2 * cornerContour_io_Array2DTriangles.get_cx(data) / this.width));
			cornerContour_io_ColorTriangles2D.set_cy(this.arrData,1 - 2 * cornerContour_io_Array2DTriangles.get_cy(data) / this.height);
		}
	}
	,drawContours: function() {
		haxe_Log.trace("drawContours",{ fileName : "src/cornerContourWebGLTest/CornerContourWebGL2.js.hx", lineNumber : 109, className : "cornerContourWebGLTest.CornerContourWebGL2", methodName : "drawContours"});
		this.pen2D = new cornerContour_Pen2D(-16776961);
		this.pen2D.currentColor = -16776961;
		this.enneagram(150,510,2);
		this.heptagram(370,240,5);
		this.pentagram(50,140,10);
	}
	,enneagram: function(x,y,size) {
		this.sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		var sides = 9;
		var angle = 200.;
		var s = this.pen2D.arr[0] | 0;
		var _this = this.sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("SET_POSITION");
			_this.historyParameters.push(x);
			_this.historyParameters.push(y);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("SET_POSITION");
			_this.turtleParameters.push(x);
			_this.turtleParameters.push(y);
		} else {
			if(_this.endLine == 2 || _this.endLine == 3) {
				_this.contour.end(_this.width);
			}
			_this.x = x;
			_this.y = y;
			var l = _this.points.length;
			_this.points[l] = [];
			_this.points[l][0] = x;
			_this.points[l][1] = y;
			_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
			_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
			_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = _this.dim[_this.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			_this.contour.reset();
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_SIZE");
			_this1.historyParameters.push(size);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_SIZE");
			_this1.turtleParameters.push(size);
		} else {
			_this1.width = size;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("YELLOW");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("YELLOW");
		} else {
			_this.pen.currentColor = -256;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_COLOR_CHANGE");
			_this1.historyParameters.push(-0.09);
			_this1.historyParameters.push(0.01);
			_this1.historyParameters.push(0.09);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_COLOR_CHANGE");
			_this1.turtleParameters.push(-0.09);
			_this1.turtleParameters.push(0.01);
			_this1.turtleParameters.push(0.09);
		} else {
			var c = _this1.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + (-0.09)) * 255) << 16 | Math.round((g0 + 0.01) * 255) << 8 | Math.round((b0 + 0.09) * 255);
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("WEST");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("WEST");
		} else {
			_this.rotation = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FILL_OFF");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FILL_OFF");
		} else {
			_this1.fill = false;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("BEGIN_REPEAT");
			_this.historyParameters.push(Math.round(sides));
		}
		if(_this.repeatCommands == true) {
			_this.repeatCommands = false;
			if(_this.turtleHistoryOn) {
				_this.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = _this.turtleHistoryOn;
			_this.turtleHistoryOn = false;
			var v = _this.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = _this.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = _this.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = _this.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius);
							_this.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius);
								_this.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = _this.x;
								var oy = _this.y;
								var arr = [];
								arr.push(_this.x);
								arr.push(_this.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									_this.rotation += rotate;
									var wasHistoryOn1 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength);
									} else {
										var nx = _this.x + baseLength * Math.cos(_this.rotation);
										var ny = _this.y + baseLength * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength;
											_this.lineTo(nx,ny);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx;
											_this.y = ny;
											var l = _this.points.length;
											_this.points[l] = [];
											_this.points[l][0] = nx;
											_this.points[l][1] = ny;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = _this.dim[_this.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn1;
									if(_this.fill) {
										arr.push(_this.x);
										arr.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARCH_BEZIER");
							_this.historyParameters.push(distance);
							_this.historyParameters.push(distance2);
							_this.historyParameters.push(radius1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARCH_BEZIER");
							_this.turtleParameters.push(distance);
							_this.turtleParameters.push(distance2);
							_this.turtleParameters.push(radius1);
						} else {
							var nx1 = _this.x + distance * Math.cos(_this.rotation);
							var ny1 = _this.y + distance * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (_this.x + nx1);
								var newy = 2 * thruY - 0.5 * (_this.y + ny1);
								_this.tempArr = [];
								var p = _this.tempArr;
								var ax = _this.x;
								var ay = _this.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = _this.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = x_;
									_this.y = y_;
									var l4 = _this.points.length;
									_this.points[l4] = [];
									_this.points[l4][0] = x_;
									_this.points[l4][1] = y_;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = _this.dim[_this.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									_this.contour.reset();
								} else {
									_this.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = _this.x;
								var oy1 = _this.y;
								while(i3 < l3) {
									if(_this.fill && _this.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									_this.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(_this.fill && _this.penIsDown) {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = ox1;
									_this.y = oy1;
									var l5 = _this.points.length;
									_this.points[l5] = [];
									_this.points[l5][0] = ox1;
									_this.points[l5][1] = oy1;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = _this.dim[_this.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									_this.contour.reset();
									_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								_this.x = nx1;
								_this.y = ny1;
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx1;
								_this.y = ny1;
								var l6 = _this.points.length;
								_this.points[l6] = [];
								_this.points[l6][0] = nx1;
								_this.points[l6][1] = ny1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = _this.dim[_this.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides1 = v[j + 2];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides1 == 24) {
								_this.historyAdd("ARC");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
							} else {
								_this.historyAdd("ARC_SIDES");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
								_this.historyParameters.push(sides1);
							}
						}
						if(radius2 != 0) {
							if(_this.repeatCommands) {
								if(sides1 == 24) {
									_this.turtleCommands.push("ARC");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
								} else {
									_this.turtleCommands.push("ARC_SIDES");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
									_this.turtleParameters.push(sides1);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides1;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = _this.x;
								var oy2 = _this.y;
								var arr2 = [];
								arr2.push(_this.x);
								arr2.push(_this.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									_this.rotation += rotate1;
									var wasHistoryOn2 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength1);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength1);
									} else {
										var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
										var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength1;
											_this.lineTo(nx2,ny2);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx2;
											_this.y = ny2;
											var l7 = _this.points.length;
											_this.points[l7] = [];
											_this.points[l7][0] = nx2;
											_this.points[l7][1] = ny2;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = _this.dim[_this.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn2;
									if(_this.fill) {
										arr2.push(_this.x);
										arr2.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BACKWARD");
							_this.historyParameters.push(distance1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BACKWARD");
							_this.turtleParameters.push(distance1);
						} else {
							var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
							var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
							if(_this.penIsDown) {
								_this.lineTo(nx3,ny3);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx3;
								_this.y = ny3;
								var l9 = _this.points.length;
								_this.points[l9] = [];
								_this.points[l9][0] = nx3;
								_this.points[l9][1] = ny3;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = _this.dim[_this.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLACK");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLACK");
						} else {
							_this.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLUE");
						} else {
							_this.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BROWN");
						} else {
							_this.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = _this.x;
								var oy3 = _this.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									_this.rotation += rotate2;
									var wasHistoryOn3 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength2);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength2);
									} else {
										var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
										var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength2;
											_this.lineTo(nx4,ny4);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx4;
											_this.y = ny4;
											var l10 = _this.points.length;
											_this.points[l10] = [];
											_this.points[l10][0] = nx4;
											_this.points[l10][1] = ny4;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = _this.dim[_this.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn3;
									if(_this.fill) {
										arr3.push(_this.x);
										arr3.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides2 = v[j + 1];
						if(sides2 == null) {
							sides2 = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides2 == 24) {
								_this.historyAdd("CIRCLE");
								_this.historyParameters.push(radius4);
							} else {
								_this.historyAdd("CIRCLE_SIDES");
								_this.historyParameters.push(radius4);
								_this.historyParameters.push(sides2);
							}
						}
						if(radius4 != 0) {
							if(_this.repeatCommands) {
								if(sides2 == 24) {
									_this.turtleCommands.push("CIRCLE");
									_this.turtleParameters.push(radius4);
								} else {
									_this.turtleCommands.push("CIRCLE_SIDES");
									_this.turtleParameters.push(radius4);
									_this.turtleParameters.push(sides2);
								}
							} else {
								var beta3 = 2 * Math.PI / sides2;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = _this.x;
								var oy4 = _this.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									_this.rotation += rotate3;
									var wasHistoryOn4 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength3);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength3);
									} else {
										var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
										var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength3;
											_this.lineTo(nx5,ny5);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx5;
											_this.y = ny5;
											var l12 = _this.points.length;
											_this.points[l12] = [];
											_this.points[l12][0] = nx5;
											_this.points[l12][1] = ny5;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = _this.dim[_this.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn4;
									if(_this.fill) {
										arr4.push(_this.x);
										arr4.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CYAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CYAN");
						} else {
							_this.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARKISH_BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARKISH_BLUE");
						} else {
							_this.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARK_GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARK_GREEN");
						} else {
							_this.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("EAST");
						} else {
							_this.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_OFF");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_OFF");
						} else {
							_this.fill = false;
						}
						break;
					case "FILL_ON":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_ON");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_ON");
						} else {
							_this.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance3);
						} else {
							var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
							var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance3;
								_this.lineTo(nx6,ny6);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx6;
								_this.y = ny6;
								var l14 = _this.points.length;
								_this.points[l14] = [];
								_this.points[l14][0] = nx6;
								_this.points[l14][1] = ny6;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = _this.dim[_this.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_CHANGE");
							_this.historyParameters.push(deltaDistance);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_CHANGE");
							_this.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = _this.lastDistance + deltaDistance;
							var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
							var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance4 + deltaDistance;
								_this.lineTo(nx7,ny7);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx7;
								_this.y = ny7;
								var l15 = _this.points.length;
								_this.points[l15] = [];
								_this.points[l15][0] = nx7;
								_this.points[l15][1] = ny7;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = _this.dim[_this.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_FACTOR");
							_this.historyParameters.push(factor);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_FACTOR");
							_this.turtleParameters.push(factor);
						} else {
							var distance5 = _this.lastDistance * factor;
							var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
							var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance5;
								_this.lineTo(nx8,ny8);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx8;
								_this.y = ny8;
								var l16 = _this.points.length;
								_this.points[l16] = [];
								_this.points[l16][0] = nx8;
								_this.points[l16][1] = ny8;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = _this.dim[_this.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREEN");
						} else {
							_this.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREY");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREY");
						} else {
							_this.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LEFT");
							_this.historyParameters.push(degrees2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LEFT");
							_this.turtleParameters.push(degrees2);
						} else {
							_this.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LIGHT_BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LIGHT_BROWN");
						} else {
							_this.pen.currentColor = -3831790;
						}
						break;
					case "MAGENTA":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("MAGENTA");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MAGENTA");
						} else {
							_this.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MOVE_PEN");
							_this.turtleParameters.push(distance6);
						} else if(_this.penIsDown) {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_UP");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_UP");
							} else {
								_this.penIsDown = false;
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx9,ny9);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx9;
									_this.y = ny9;
									var l17 = _this.points.length;
									_this.points[l17] = [];
									_this.points[l17][0] = nx9;
									_this.points[l17][1] = ny9;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = _this.dim[_this.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									_this.contour.reset();
								}
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_DOWN");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_DOWN");
							} else {
								_this.penIsDown = true;
							}
						} else {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx10,ny10);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx10;
									_this.y = ny10;
									var l18 = _this.points.length;
									_this.points[l18] = [];
									_this.points[l18][0] = nx10;
									_this.points[l18][1] = ny10;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = _this.dim[_this.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									_this.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("NORTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("NORTH");
						} else {
							_this.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ORANGE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ORANGE");
						} else {
							_this.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR");
							_this.historyParameters.push(r);
							_this.historyParameters.push(g);
							_this.historyParameters.push(b);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR");
							_this.turtleParameters.push(r);
							_this.turtleParameters.push(g);
							_this.turtleParameters.push(b);
						} else {
							_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_B");
							_this.historyParameters.push(r1);
							_this.historyParameters.push(g1);
							_this.historyParameters.push(b1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_B");
							_this.turtleParameters.push(r1);
							_this.turtleParameters.push(g1);
							_this.turtleParameters.push(b1);
						} else {
							_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_C");
							_this.historyParameters.push(r2);
							_this.historyParameters.push(g2);
							_this.historyParameters.push(b2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_C");
							_this.turtleParameters.push(r2);
							_this.turtleParameters.push(g2);
							_this.turtleParameters.push(b2);
						} else {
							_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE");
							_this.historyParameters.push(r3);
							_this.historyParameters.push(g3);
							_this.historyParameters.push(b3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE");
							_this.turtleParameters.push(r3);
							_this.turtleParameters.push(g3);
							_this.turtleParameters.push(b3);
						} else {
							var c = _this.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_B");
							_this.historyParameters.push(r4);
							_this.historyParameters.push(g4);
							_this.historyParameters.push(b4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
							_this.turtleParameters.push(r4);
							_this.turtleParameters.push(g4);
							_this.turtleParameters.push(b4);
						} else {
							var c1 = _this.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_C");
							_this.historyParameters.push(r5);
							_this.historyParameters.push(g5);
							_this.historyParameters.push(b5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
							_this.turtleParameters.push(r5);
							_this.turtleParameters.push(g5);
							_this.turtleParameters.push(b5);
						} else {
							var c2 = _this.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE");
							_this.historyParameters.push(w);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE");
							_this.turtleParameters.push(w);
						} else {
							_this.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_CHANGE");
							_this.historyParameters.push(dw);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_CHANGE");
							_this.turtleParameters.push(dw);
						} else {
							_this.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_FACTOR");
							_this.historyParameters.push(factor1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_FACTOR");
							_this.turtleParameters.push(factor1);
						} else {
							_this.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						break;
					case "PLUM":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PLUM");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PLUM");
						} else {
							_this.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RED");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RED");
						} else {
							_this.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RIGHT");
							_this.historyParameters.push(degrees3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RIGHT");
							_this.turtleParameters.push(degrees3);
						} else {
							_this.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_ANGLE");
							_this.historyParameters.push(degrees4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_ANGLE");
							_this.turtleParameters.push(degrees4);
						} else {
							_this.rotation = -Math.PI / 2;
							_this.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_POSITION");
							_this.historyParameters.push(x2);
							_this.historyParameters.push(y2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_POSITION");
							_this.turtleParameters.push(x2);
							_this.turtleParameters.push(y2);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = x2;
							_this.y = y2;
							var l19 = _this.points.length;
							_this.points[l19] = [];
							_this.points[l19][0] = x2;
							_this.points[l19][1] = y2;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = _this.dim[_this.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							_this.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SOUTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SOUTH");
						} else {
							_this.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TAN");
						} else {
							_this.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TRIANGLE_ARCH");
							_this.historyParameters.push(distance7);
							_this.historyParameters.push(distance21);
							_this.historyParameters.push(radius5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TRIANGLE_ARCH");
							_this.turtleParameters.push(distance7);
							_this.turtleParameters.push(distance21);
							_this.turtleParameters.push(radius5);
						} else {
							var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
							var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
								if(_this.fill) {
									_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
								}
								_this.lineTo(thruX1,thruY1);
								_this.lineTo(nx11,ny11);
								if(_this.fill) {
									_this.lineTo(_this.x,_this.y);
								}
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l20 = _this.points.length;
								_this.points[l20] = [];
								_this.points[l20][0] = nx11;
								_this.points[l20][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = _this.dim[_this.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								_this.contour.reset();
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l21 = _this.points.length;
								_this.points[l21] = [];
								_this.points[l21][0] = nx11;
								_this.points[l21][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = _this.dim[_this.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WEST");
						} else {
							_this.rotation = 0;
						}
						break;
					case "WHITE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WHITE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WHITE");
						} else {
							_this.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("YELLOW");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("YELLOW");
						} else {
							_this.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			_this.turtleHistoryOn = wasHistoryOn;
			_this.turtleCommands.length = 0;
			_this.turtleParameters.length = 0;
		}
		if(sides > 0) {
			_this.repeatCount = Math.round(sides);
			_this.repeatCommands = true;
			_this.turtleCommands.length = 0;
			_this.turtleParameters.length = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARCH_BEZIER");
			_this1.historyParameters.push(300);
			_this1.historyParameters.push(150);
			_this1.historyParameters.push(-10);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARCH_BEZIER");
			_this1.turtleParameters.push(300);
			_this1.turtleParameters.push(150);
			_this1.turtleParameters.push(-10);
		} else {
			var nx = _this1.x + 300 * Math.cos(_this1.rotation);
			var ny = _this1.y + 300 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				var thruX = _this1.x + 150 * Math.cos(_this1.rotation) - -10 * Math.cos(_this1.rotation + Math.PI / 2);
				var thruY = _this1.y + 150 * Math.sin(_this1.rotation) - -10 * Math.sin(_this1.rotation + Math.PI / 2);
				var newx = 2 * thruX - 0.5 * (_this1.x + nx);
				var newy = 2 * thruY - 0.5 * (_this1.y + ny);
				_this1.tempArr = [];
				var p = _this1.tempArr;
				var ax = _this1.x;
				var ay = _this1.y;
				var x = ax - newx;
				var y = ay - newy;
				var x1 = newx - nx;
				var y1 = newy - ny;
				var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
				if(approxDistance == 0) {
					approxDistance = 0.000001;
				}
				var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
				var l = p.length;
				p[l++] = ax;
				p[l++] = ay;
				var t = step;
				while(t < 1.) {
					var u = 1 - t;
					p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx;
					var u1 = 1 - t;
					p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny;
					t += step;
				}
				p[l++] = nx;
				p[l++] = ny;
				var arr = _this1.tempArr;
				var withMove = false;
				if(withMove == null) {
					withMove = true;
				}
				var l = arr.length;
				var i = 2;
				if(withMove) {
					var x_ = arr[0];
					var y_ = arr[1];
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = x_;
					_this1.y = y_;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = x_;
					_this1.points[l1][1] = y_;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(x_ < d.minX) {
						d.minX = x_;
					}
					if(x_ > d.maxX) {
						d.maxX = x_;
					}
					if(y_ < d.minY) {
						d.minY = y_;
					}
					if(y_ > d.maxY) {
						d.maxY = y_;
					}
					_this1.contour.reset();
				} else {
					_this1.lineTo(arr[0],arr[1]);
				}
				var cx = (arr[0] + arr[l - 2]) / 2;
				var cy = (arr[1] + arr[l - 1]) / 2;
				var ox = _this1.x;
				var oy = _this1.y;
				while(i < l) {
					if(_this1.fill && _this1.penIsDown) {
						if(i > 0 && i < l - 2) {
							_this1.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
						}
					}
					_this1.lineTo(arr[i],arr[i + 1]);
					i += 2;
				}
				if(_this1.fill && _this1.penIsDown) {
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = ox;
					_this1.y = oy;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = ox;
					_this1.points[l1][1] = oy;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(ox < d.minX) {
						d.minX = ox;
					}
					if(ox > d.maxX) {
						d.maxX = ox;
					}
					if(oy < d.minY) {
						d.minY = oy;
					}
					if(oy > d.maxY) {
						d.maxY = oy;
					}
					_this1.contour.reset();
					_this1.lineTo(arr[l - 2],arr[l - 1]);
				}
				_this1.x = nx;
				_this1.y = ny;
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(angle);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(angle);
		} else {
			_this.rotation += angle * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_COLOR_CHANGE");
			_this1.historyParameters.push(-0.09);
			_this1.historyParameters.push(0.01);
			_this1.historyParameters.push(0.09);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_COLOR_CHANGE");
			_this1.turtleParameters.push(-0.09);
			_this1.turtleParameters.push(0.01);
			_this1.turtleParameters.push(0.09);
		} else {
			var c = _this1.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + (-0.09)) * 255) << 16 | Math.round((g0 + 0.01) * 255) << 8 | Math.round((b0 + 0.09) * 255);
		}
		var _this = _this1;
		_this.repeatCommands = false;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = _this.turtleHistoryOn;
		_this.turtleHistoryOn = false;
		var v = _this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = _this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = _this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = _this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARC");
						_this.historyParameters.push(radius);
						_this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARC");
							_this.turtleParameters.push(radius);
							_this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = _this.x;
							var oy = _this.y;
							var arr = [];
							arr.push(_this.x);
							arr.push(_this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								_this.rotation += rotate;
								var wasHistoryOn1 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength);
								} else {
									var nx = _this.x + baseLength * Math.cos(_this.rotation);
									var ny = _this.y + baseLength * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength;
										_this.lineTo(nx,ny);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx;
										_this.y = ny;
										var l = _this.points.length;
										_this.points[l] = [];
										_this.points[l][0] = nx;
										_this.points[l][1] = ny;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = _this.dim[_this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn1;
								if(_this.fill) {
									arr.push(_this.x);
									arr.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARCH_BEZIER");
						_this.historyParameters.push(distance);
						_this.historyParameters.push(distance2);
						_this.historyParameters.push(radius1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ARCH_BEZIER");
						_this.turtleParameters.push(distance);
						_this.turtleParameters.push(distance2);
						_this.turtleParameters.push(radius1);
					} else {
						var nx1 = _this.x + distance * Math.cos(_this.rotation);
						var ny1 = _this.y + distance * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (_this.x + nx1);
							var newy = 2 * thruY - 0.5 * (_this.y + ny1);
							_this.tempArr = [];
							var p = _this.tempArr;
							var ax = _this.x;
							var ay = _this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = _this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = x_;
								_this.y = y_;
								var l4 = _this.points.length;
								_this.points[l4] = [];
								_this.points[l4][0] = x_;
								_this.points[l4][1] = y_;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = _this.dim[_this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								_this.contour.reset();
							} else {
								_this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = _this.x;
							var oy1 = _this.y;
							while(i3 < l3) {
								if(_this.fill && _this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								_this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(_this.fill && _this.penIsDown) {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = ox1;
								_this.y = oy1;
								var l5 = _this.points.length;
								_this.points[l5] = [];
								_this.points[l5][0] = ox1;
								_this.points[l5][1] = oy1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = _this.dim[_this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								_this.contour.reset();
								_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							_this.x = nx1;
							_this.y = ny1;
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx1;
							_this.y = ny1;
							var l6 = _this.points.length;
							_this.points[l6] = [];
							_this.points[l6][0] = nx1;
							_this.points[l6][1] = ny1;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = _this.dim[_this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides == 24) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
						} else {
							_this.historyAdd("ARC_SIDES");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
							_this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(_this.repeatCommands) {
							if(sides == 24) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
							} else {
								_this.turtleCommands.push("ARC_SIDES");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
								_this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = _this.x;
							var oy2 = _this.y;
							var arr2 = [];
							arr2.push(_this.x);
							arr2.push(_this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								_this.rotation += rotate1;
								var wasHistoryOn2 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength1);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
									var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength1;
										_this.lineTo(nx2,ny2);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx2;
										_this.y = ny2;
										var l7 = _this.points.length;
										_this.points[l7] = [];
										_this.points[l7][0] = nx2;
										_this.points[l7][1] = ny2;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = _this.dim[_this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn2;
								if(_this.fill) {
									arr2.push(_this.x);
									arr2.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BACKWARD");
						_this.historyParameters.push(distance1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BACKWARD");
						_this.turtleParameters.push(distance1);
					} else {
						var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
						var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
						if(_this.penIsDown) {
							_this.lineTo(nx3,ny3);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx3;
							_this.y = ny3;
							var l9 = _this.points.length;
							_this.points[l9] = [];
							_this.points[l9][0] = nx3;
							_this.points[l9][1] = ny3;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = _this.dim[_this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLACK");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLACK");
					} else {
						_this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLUE");
					} else {
						_this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BROWN");
					} else {
						_this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CIRCLE");
						_this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CIRCLE");
							_this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = _this.x;
							var oy3 = _this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								_this.rotation += rotate2;
								var wasHistoryOn3 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength2);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
									var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength2;
										_this.lineTo(nx4,ny4);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx4;
										_this.y = ny4;
										var l10 = _this.points.length;
										_this.points[l10] = [];
										_this.points[l10][0] = nx4;
										_this.points[l10][1] = ny4;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = _this.dim[_this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn3;
								if(_this.fill) {
									arr3.push(_this.x);
									arr3.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides1 == 24) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius4);
						} else {
							_this.historyAdd("CIRCLE_SIDES");
							_this.historyParameters.push(radius4);
							_this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(_this.repeatCommands) {
							if(sides1 == 24) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius4);
							} else {
								_this.turtleCommands.push("CIRCLE_SIDES");
								_this.turtleParameters.push(radius4);
								_this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = _this.x;
							var oy4 = _this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								_this.rotation += rotate3;
								var wasHistoryOn4 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength3);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
									var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength3;
										_this.lineTo(nx5,ny5);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx5;
										_this.y = ny5;
										var l12 = _this.points.length;
										_this.points[l12] = [];
										_this.points[l12][0] = nx5;
										_this.points[l12][1] = ny5;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = _this.dim[_this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn4;
								if(_this.fill) {
									arr4.push(_this.x);
									arr4.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CYAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("CYAN");
					} else {
						_this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARKISH_BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARKISH_BLUE");
					} else {
						_this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARK_GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARK_GREEN");
					} else {
						_this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("EAST");
					} else {
						_this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_OFF");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_OFF");
					} else {
						_this.fill = false;
					}
					break;
				case "FILL_ON":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_ON");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_ON");
					} else {
						_this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD");
						_this.historyParameters.push(distance3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD");
						_this.turtleParameters.push(distance3);
					} else {
						var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
						var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance3;
							_this.lineTo(nx6,ny6);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx6;
							_this.y = ny6;
							var l14 = _this.points.length;
							_this.points[l14] = [];
							_this.points[l14][0] = nx6;
							_this.points[l14][1] = ny6;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = _this.dim[_this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_CHANGE");
						_this.historyParameters.push(deltaDistance);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_CHANGE");
						_this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = _this.lastDistance + deltaDistance;
						var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
						var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance4 + deltaDistance;
							_this.lineTo(nx7,ny7);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx7;
							_this.y = ny7;
							var l15 = _this.points.length;
							_this.points[l15] = [];
							_this.points[l15][0] = nx7;
							_this.points[l15][1] = ny7;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = _this.dim[_this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_FACTOR");
						_this.historyParameters.push(factor);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_FACTOR");
						_this.turtleParameters.push(factor);
					} else {
						var distance5 = _this.lastDistance * factor;
						var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
						var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance5;
							_this.lineTo(nx8,ny8);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx8;
							_this.y = ny8;
							var l16 = _this.points.length;
							_this.points[l16] = [];
							_this.points[l16][0] = nx8;
							_this.points[l16][1] = ny8;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = _this.dim[_this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREEN");
					} else {
						_this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREY");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREY");
					} else {
						_this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LEFT");
						_this.historyParameters.push(degrees2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LEFT");
						_this.turtleParameters.push(degrees2);
					} else {
						_this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LIGHT_BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LIGHT_BROWN");
					} else {
						_this.pen.currentColor = -3831790;
					}
					break;
				case "MAGENTA":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("MAGENTA");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MAGENTA");
					} else {
						_this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MOVE_PEN");
						_this.turtleParameters.push(distance6);
					} else if(_this.penIsDown) {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx9,ny9);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx9;
								_this.y = ny9;
								var l17 = _this.points.length;
								_this.points[l17] = [];
								_this.points[l17][0] = nx9;
								_this.points[l17][1] = ny9;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = _this.dim[_this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								_this.contour.reset();
							}
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
					} else {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx10,ny10);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx10;
								_this.y = ny10;
								var l18 = _this.points.length;
								_this.points[l18] = [];
								_this.points[l18][0] = nx10;
								_this.points[l18][1] = ny10;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = _this.dim[_this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								_this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("NORTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("NORTH");
					} else {
						_this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ORANGE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ORANGE");
					} else {
						_this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR");
						_this.historyParameters.push(r);
						_this.historyParameters.push(g);
						_this.historyParameters.push(b);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR");
						_this.turtleParameters.push(r);
						_this.turtleParameters.push(g);
						_this.turtleParameters.push(b);
					} else {
						_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_B");
						_this.historyParameters.push(r1);
						_this.historyParameters.push(g1);
						_this.historyParameters.push(b1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_B");
						_this.turtleParameters.push(r1);
						_this.turtleParameters.push(g1);
						_this.turtleParameters.push(b1);
					} else {
						_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_C");
						_this.historyParameters.push(r2);
						_this.historyParameters.push(g2);
						_this.historyParameters.push(b2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_C");
						_this.turtleParameters.push(r2);
						_this.turtleParameters.push(g2);
						_this.turtleParameters.push(b2);
					} else {
						_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE");
						_this.historyParameters.push(r3);
						_this.historyParameters.push(g3);
						_this.historyParameters.push(b3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE");
						_this.turtleParameters.push(r3);
						_this.turtleParameters.push(g3);
						_this.turtleParameters.push(b3);
					} else {
						var c = _this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_B");
						_this.historyParameters.push(r4);
						_this.historyParameters.push(g4);
						_this.historyParameters.push(b4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						_this.turtleParameters.push(r4);
						_this.turtleParameters.push(g4);
						_this.turtleParameters.push(b4);
					} else {
						var c1 = _this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_C");
						_this.historyParameters.push(r5);
						_this.historyParameters.push(g5);
						_this.historyParameters.push(b5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						_this.turtleParameters.push(r5);
						_this.turtleParameters.push(g5);
						_this.turtleParameters.push(b5);
					} else {
						var c2 = _this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_DOWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_DOWN");
					} else {
						_this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE");
						_this.historyParameters.push(w);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE");
						_this.turtleParameters.push(w);
					} else {
						_this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_CHANGE");
						_this.historyParameters.push(dw);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_CHANGE");
						_this.turtleParameters.push(dw);
					} else {
						_this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_FACTOR");
						_this.historyParameters.push(factor1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_FACTOR");
						_this.turtleParameters.push(factor1);
					} else {
						_this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_UP");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_UP");
					} else {
						_this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PLUM");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PLUM");
					} else {
						_this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RED");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RED");
					} else {
						_this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RIGHT");
						_this.historyParameters.push(degrees3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RIGHT");
						_this.turtleParameters.push(degrees3);
					} else {
						_this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_ANGLE");
						_this.historyParameters.push(degrees4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_ANGLE");
						_this.turtleParameters.push(degrees4);
					} else {
						_this.rotation = -Math.PI / 2;
						_this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_POSITION");
						_this.historyParameters.push(x2);
						_this.historyParameters.push(y2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_POSITION");
						_this.turtleParameters.push(x2);
						_this.turtleParameters.push(y2);
					} else {
						if(_this.endLine == 2 || _this.endLine == 3) {
							_this.contour.end(_this.width);
						}
						_this.x = x2;
						_this.y = y2;
						var l19 = _this.points.length;
						_this.points[l19] = [];
						_this.points[l19][0] = x2;
						_this.points[l19][1] = y2;
						_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
						_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
						_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = _this.dim[_this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						_this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SOUTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SOUTH");
					} else {
						_this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TAN");
					} else {
						_this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TRIANGLE_ARCH");
						_this.historyParameters.push(distance7);
						_this.historyParameters.push(distance21);
						_this.historyParameters.push(radius5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TRIANGLE_ARCH");
						_this.turtleParameters.push(distance7);
						_this.turtleParameters.push(distance21);
						_this.turtleParameters.push(radius5);
					} else {
						var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
						var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
							if(_this.fill) {
								_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
							}
							_this.lineTo(thruX1,thruY1);
							_this.lineTo(nx11,ny11);
							if(_this.fill) {
								_this.lineTo(_this.x,_this.y);
							}
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l20 = _this.points.length;
							_this.points[l20] = [];
							_this.points[l20][0] = nx11;
							_this.points[l20][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = _this.dim[_this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							_this.contour.reset();
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l21 = _this.points.length;
							_this.points[l21] = [];
							_this.points[l21][0] = nx11;
							_this.points[l21][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = _this.dim[_this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WEST");
					} else {
						_this.rotation = 0;
					}
					break;
				case "WHITE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WHITE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WHITE");
					} else {
						_this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("YELLOW");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("YELLOW");
					} else {
						_this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		_this.turtleHistoryOn = wasHistoryOn;
		_this.turtleCommands.length = 0;
		_this.turtleParameters.length = 0;
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BLUE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("BLUE");
		} else {
			_this1.pen.currentColor = -16776961;
		}
		var tmp = this.allRange;
		var ii_min = s;
		var ii_max = this.pen2D.arr[0] | 0;
		var this1 = new cornerContour_io_IntIterStart(ii_min,ii_max);
		tmp.push(this1);
	}
	,heptagram: function(x,y,size) {
		var sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		var sides = 7;
		var angle = 154.285714285714278;
		var s = this.pen2D.arr[0] | 0;
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(size);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(size);
		} else {
			_this.width = size;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PLUM");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PLUM");
		} else {
			_this1.pen.currentColor = -7310896;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("WEST");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("WEST");
		} else {
			_this.rotation = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FILL_OFF");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FILL_OFF");
		} else {
			_this1.fill = false;
		}
		var _this = _this1;
		var repeatCount_ = sides + 1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("BEGIN_REPEAT");
			_this.historyParameters.push(Math.round(repeatCount_));
		}
		if(_this.repeatCommands == true) {
			_this.repeatCommands = false;
			if(_this.turtleHistoryOn) {
				_this.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = _this.turtleHistoryOn;
			_this.turtleHistoryOn = false;
			var v = _this.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = _this.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = _this.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = _this.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius);
							_this.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius);
								_this.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = _this.x;
								var oy = _this.y;
								var arr = [];
								arr.push(_this.x);
								arr.push(_this.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									_this.rotation += rotate;
									var wasHistoryOn1 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength);
									} else {
										var nx = _this.x + baseLength * Math.cos(_this.rotation);
										var ny = _this.y + baseLength * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength;
											_this.lineTo(nx,ny);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx;
											_this.y = ny;
											var l = _this.points.length;
											_this.points[l] = [];
											_this.points[l][0] = nx;
											_this.points[l][1] = ny;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = _this.dim[_this.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn1;
									if(_this.fill) {
										arr.push(_this.x);
										arr.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARCH_BEZIER");
							_this.historyParameters.push(distance);
							_this.historyParameters.push(distance2);
							_this.historyParameters.push(radius1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARCH_BEZIER");
							_this.turtleParameters.push(distance);
							_this.turtleParameters.push(distance2);
							_this.turtleParameters.push(radius1);
						} else {
							var nx1 = _this.x + distance * Math.cos(_this.rotation);
							var ny1 = _this.y + distance * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (_this.x + nx1);
								var newy = 2 * thruY - 0.5 * (_this.y + ny1);
								_this.tempArr = [];
								var p = _this.tempArr;
								var ax = _this.x;
								var ay = _this.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = _this.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = x_;
									_this.y = y_;
									var l4 = _this.points.length;
									_this.points[l4] = [];
									_this.points[l4][0] = x_;
									_this.points[l4][1] = y_;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = _this.dim[_this.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									_this.contour.reset();
								} else {
									_this.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = _this.x;
								var oy1 = _this.y;
								while(i3 < l3) {
									if(_this.fill && _this.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									_this.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(_this.fill && _this.penIsDown) {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = ox1;
									_this.y = oy1;
									var l5 = _this.points.length;
									_this.points[l5] = [];
									_this.points[l5][0] = ox1;
									_this.points[l5][1] = oy1;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = _this.dim[_this.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									_this.contour.reset();
									_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								_this.x = nx1;
								_this.y = ny1;
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx1;
								_this.y = ny1;
								var l6 = _this.points.length;
								_this.points[l6] = [];
								_this.points[l6][0] = nx1;
								_this.points[l6][1] = ny1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = _this.dim[_this.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides == 24) {
								_this.historyAdd("ARC");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
							} else {
								_this.historyAdd("ARC_SIDES");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
								_this.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(_this.repeatCommands) {
								if(sides == 24) {
									_this.turtleCommands.push("ARC");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
								} else {
									_this.turtleCommands.push("ARC_SIDES");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
									_this.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = _this.x;
								var oy2 = _this.y;
								var arr2 = [];
								arr2.push(_this.x);
								arr2.push(_this.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									_this.rotation += rotate1;
									var wasHistoryOn2 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength1);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength1);
									} else {
										var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
										var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength1;
											_this.lineTo(nx2,ny2);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx2;
											_this.y = ny2;
											var l7 = _this.points.length;
											_this.points[l7] = [];
											_this.points[l7][0] = nx2;
											_this.points[l7][1] = ny2;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = _this.dim[_this.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn2;
									if(_this.fill) {
										arr2.push(_this.x);
										arr2.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BACKWARD");
							_this.historyParameters.push(distance1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BACKWARD");
							_this.turtleParameters.push(distance1);
						} else {
							var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
							var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
							if(_this.penIsDown) {
								_this.lineTo(nx3,ny3);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx3;
								_this.y = ny3;
								var l9 = _this.points.length;
								_this.points[l9] = [];
								_this.points[l9][0] = nx3;
								_this.points[l9][1] = ny3;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = _this.dim[_this.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLACK");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLACK");
						} else {
							_this.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLUE");
						} else {
							_this.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BROWN");
						} else {
							_this.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = _this.x;
								var oy3 = _this.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									_this.rotation += rotate2;
									var wasHistoryOn3 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength2);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength2);
									} else {
										var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
										var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength2;
											_this.lineTo(nx4,ny4);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx4;
											_this.y = ny4;
											var l10 = _this.points.length;
											_this.points[l10] = [];
											_this.points[l10][0] = nx4;
											_this.points[l10][1] = ny4;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = _this.dim[_this.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn3;
									if(_this.fill) {
										arr3.push(_this.x);
										arr3.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides1 == 24) {
								_this.historyAdd("CIRCLE");
								_this.historyParameters.push(radius4);
							} else {
								_this.historyAdd("CIRCLE_SIDES");
								_this.historyParameters.push(radius4);
								_this.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(_this.repeatCommands) {
								if(sides1 == 24) {
									_this.turtleCommands.push("CIRCLE");
									_this.turtleParameters.push(radius4);
								} else {
									_this.turtleCommands.push("CIRCLE_SIDES");
									_this.turtleParameters.push(radius4);
									_this.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = _this.x;
								var oy4 = _this.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									_this.rotation += rotate3;
									var wasHistoryOn4 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength3);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength3);
									} else {
										var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
										var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength3;
											_this.lineTo(nx5,ny5);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx5;
											_this.y = ny5;
											var l12 = _this.points.length;
											_this.points[l12] = [];
											_this.points[l12][0] = nx5;
											_this.points[l12][1] = ny5;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = _this.dim[_this.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn4;
									if(_this.fill) {
										arr4.push(_this.x);
										arr4.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CYAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CYAN");
						} else {
							_this.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARKISH_BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARKISH_BLUE");
						} else {
							_this.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARK_GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARK_GREEN");
						} else {
							_this.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("EAST");
						} else {
							_this.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_OFF");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_OFF");
						} else {
							_this.fill = false;
						}
						break;
					case "FILL_ON":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_ON");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_ON");
						} else {
							_this.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance3);
						} else {
							var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
							var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance3;
								_this.lineTo(nx6,ny6);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx6;
								_this.y = ny6;
								var l14 = _this.points.length;
								_this.points[l14] = [];
								_this.points[l14][0] = nx6;
								_this.points[l14][1] = ny6;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = _this.dim[_this.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_CHANGE");
							_this.historyParameters.push(deltaDistance);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_CHANGE");
							_this.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = _this.lastDistance + deltaDistance;
							var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
							var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance4 + deltaDistance;
								_this.lineTo(nx7,ny7);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx7;
								_this.y = ny7;
								var l15 = _this.points.length;
								_this.points[l15] = [];
								_this.points[l15][0] = nx7;
								_this.points[l15][1] = ny7;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = _this.dim[_this.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_FACTOR");
							_this.historyParameters.push(factor);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_FACTOR");
							_this.turtleParameters.push(factor);
						} else {
							var distance5 = _this.lastDistance * factor;
							var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
							var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance5;
								_this.lineTo(nx8,ny8);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx8;
								_this.y = ny8;
								var l16 = _this.points.length;
								_this.points[l16] = [];
								_this.points[l16][0] = nx8;
								_this.points[l16][1] = ny8;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = _this.dim[_this.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREEN");
						} else {
							_this.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREY");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREY");
						} else {
							_this.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LEFT");
							_this.historyParameters.push(degrees2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LEFT");
							_this.turtleParameters.push(degrees2);
						} else {
							_this.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LIGHT_BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LIGHT_BROWN");
						} else {
							_this.pen.currentColor = -3831790;
						}
						break;
					case "MAGENTA":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("MAGENTA");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MAGENTA");
						} else {
							_this.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MOVE_PEN");
							_this.turtleParameters.push(distance6);
						} else if(_this.penIsDown) {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_UP");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_UP");
							} else {
								_this.penIsDown = false;
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx9,ny9);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx9;
									_this.y = ny9;
									var l17 = _this.points.length;
									_this.points[l17] = [];
									_this.points[l17][0] = nx9;
									_this.points[l17][1] = ny9;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = _this.dim[_this.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									_this.contour.reset();
								}
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_DOWN");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_DOWN");
							} else {
								_this.penIsDown = true;
							}
						} else {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx10,ny10);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx10;
									_this.y = ny10;
									var l18 = _this.points.length;
									_this.points[l18] = [];
									_this.points[l18][0] = nx10;
									_this.points[l18][1] = ny10;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = _this.dim[_this.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									_this.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("NORTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("NORTH");
						} else {
							_this.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ORANGE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ORANGE");
						} else {
							_this.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR");
							_this.historyParameters.push(r);
							_this.historyParameters.push(g);
							_this.historyParameters.push(b);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR");
							_this.turtleParameters.push(r);
							_this.turtleParameters.push(g);
							_this.turtleParameters.push(b);
						} else {
							_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_B");
							_this.historyParameters.push(r1);
							_this.historyParameters.push(g1);
							_this.historyParameters.push(b1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_B");
							_this.turtleParameters.push(r1);
							_this.turtleParameters.push(g1);
							_this.turtleParameters.push(b1);
						} else {
							_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_C");
							_this.historyParameters.push(r2);
							_this.historyParameters.push(g2);
							_this.historyParameters.push(b2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_C");
							_this.turtleParameters.push(r2);
							_this.turtleParameters.push(g2);
							_this.turtleParameters.push(b2);
						} else {
							_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE");
							_this.historyParameters.push(r3);
							_this.historyParameters.push(g3);
							_this.historyParameters.push(b3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE");
							_this.turtleParameters.push(r3);
							_this.turtleParameters.push(g3);
							_this.turtleParameters.push(b3);
						} else {
							var c = _this.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_B");
							_this.historyParameters.push(r4);
							_this.historyParameters.push(g4);
							_this.historyParameters.push(b4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
							_this.turtleParameters.push(r4);
							_this.turtleParameters.push(g4);
							_this.turtleParameters.push(b4);
						} else {
							var c1 = _this.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_C");
							_this.historyParameters.push(r5);
							_this.historyParameters.push(g5);
							_this.historyParameters.push(b5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
							_this.turtleParameters.push(r5);
							_this.turtleParameters.push(g5);
							_this.turtleParameters.push(b5);
						} else {
							var c2 = _this.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE");
							_this.historyParameters.push(w);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE");
							_this.turtleParameters.push(w);
						} else {
							_this.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_CHANGE");
							_this.historyParameters.push(dw);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_CHANGE");
							_this.turtleParameters.push(dw);
						} else {
							_this.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_FACTOR");
							_this.historyParameters.push(factor1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_FACTOR");
							_this.turtleParameters.push(factor1);
						} else {
							_this.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						break;
					case "PLUM":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PLUM");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PLUM");
						} else {
							_this.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RED");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RED");
						} else {
							_this.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RIGHT");
							_this.historyParameters.push(degrees3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RIGHT");
							_this.turtleParameters.push(degrees3);
						} else {
							_this.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_ANGLE");
							_this.historyParameters.push(degrees4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_ANGLE");
							_this.turtleParameters.push(degrees4);
						} else {
							_this.rotation = -Math.PI / 2;
							_this.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_POSITION");
							_this.historyParameters.push(x2);
							_this.historyParameters.push(y2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_POSITION");
							_this.turtleParameters.push(x2);
							_this.turtleParameters.push(y2);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = x2;
							_this.y = y2;
							var l19 = _this.points.length;
							_this.points[l19] = [];
							_this.points[l19][0] = x2;
							_this.points[l19][1] = y2;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = _this.dim[_this.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							_this.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SOUTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SOUTH");
						} else {
							_this.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TAN");
						} else {
							_this.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TRIANGLE_ARCH");
							_this.historyParameters.push(distance7);
							_this.historyParameters.push(distance21);
							_this.historyParameters.push(radius5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TRIANGLE_ARCH");
							_this.turtleParameters.push(distance7);
							_this.turtleParameters.push(distance21);
							_this.turtleParameters.push(radius5);
						} else {
							var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
							var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
								if(_this.fill) {
									_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
								}
								_this.lineTo(thruX1,thruY1);
								_this.lineTo(nx11,ny11);
								if(_this.fill) {
									_this.lineTo(_this.x,_this.y);
								}
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l20 = _this.points.length;
								_this.points[l20] = [];
								_this.points[l20][0] = nx11;
								_this.points[l20][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = _this.dim[_this.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								_this.contour.reset();
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l21 = _this.points.length;
								_this.points[l21] = [];
								_this.points[l21][0] = nx11;
								_this.points[l21][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = _this.dim[_this.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WEST");
						} else {
							_this.rotation = 0;
						}
						break;
					case "WHITE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WHITE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WHITE");
						} else {
							_this.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("YELLOW");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("YELLOW");
						} else {
							_this.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			_this.turtleHistoryOn = wasHistoryOn;
			_this.turtleCommands.length = 0;
			_this.turtleParameters.length = 0;
		}
		if(repeatCount_ > 0) {
			_this.repeatCount = Math.round(repeatCount_);
			_this.repeatCommands = true;
			_this.turtleCommands.length = 0;
			_this.turtleParameters.length = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARCH_BEZIER");
			_this1.historyParameters.push(300);
			_this1.historyParameters.push(150);
			_this1.historyParameters.push(30);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARCH_BEZIER");
			_this1.turtleParameters.push(300);
			_this1.turtleParameters.push(150);
			_this1.turtleParameters.push(30);
		} else {
			var nx = _this1.x + 300 * Math.cos(_this1.rotation);
			var ny = _this1.y + 300 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				var thruX = _this1.x + 150 * Math.cos(_this1.rotation) - 30 * Math.cos(_this1.rotation + Math.PI / 2);
				var thruY = _this1.y + 150 * Math.sin(_this1.rotation) - 30 * Math.sin(_this1.rotation + Math.PI / 2);
				var newx = 2 * thruX - 0.5 * (_this1.x + nx);
				var newy = 2 * thruY - 0.5 * (_this1.y + ny);
				_this1.tempArr = [];
				var p = _this1.tempArr;
				var ax = _this1.x;
				var ay = _this1.y;
				var x = ax - newx;
				var y = ay - newy;
				var x1 = newx - nx;
				var y1 = newy - ny;
				var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
				if(approxDistance == 0) {
					approxDistance = 0.000001;
				}
				var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
				var l = p.length;
				p[l++] = ax;
				p[l++] = ay;
				var t = step;
				while(t < 1.) {
					var u = 1 - t;
					p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx;
					var u1 = 1 - t;
					p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny;
					t += step;
				}
				p[l++] = nx;
				p[l++] = ny;
				var arr = _this1.tempArr;
				var withMove = false;
				if(withMove == null) {
					withMove = true;
				}
				var l = arr.length;
				var i = 2;
				if(withMove) {
					var x_ = arr[0];
					var y_ = arr[1];
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = x_;
					_this1.y = y_;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = x_;
					_this1.points[l1][1] = y_;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(x_ < d.minX) {
						d.minX = x_;
					}
					if(x_ > d.maxX) {
						d.maxX = x_;
					}
					if(y_ < d.minY) {
						d.minY = y_;
					}
					if(y_ > d.maxY) {
						d.maxY = y_;
					}
					_this1.contour.reset();
				} else {
					_this1.lineTo(arr[0],arr[1]);
				}
				var cx = (arr[0] + arr[l - 2]) / 2;
				var cy = (arr[1] + arr[l - 1]) / 2;
				var ox = _this1.x;
				var oy = _this1.y;
				while(i < l) {
					if(_this1.fill && _this1.penIsDown) {
						if(i > 0 && i < l - 2) {
							_this1.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
						}
					}
					_this1.lineTo(arr[i],arr[i + 1]);
					i += 2;
				}
				if(_this1.fill && _this1.penIsDown) {
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = ox;
					_this1.y = oy;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = ox;
					_this1.points[l1][1] = oy;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(ox < d.minX) {
						d.minX = ox;
					}
					if(ox > d.maxX) {
						d.maxX = ox;
					}
					if(oy < d.minY) {
						d.minY = oy;
					}
					if(oy > d.maxY) {
						d.maxY = oy;
					}
					_this1.contour.reset();
					_this1.lineTo(arr[l - 2],arr[l - 1]);
				}
				_this1.x = nx;
				_this1.y = ny;
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(angle);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(angle);
		} else {
			_this.rotation += angle * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_COLOR_CHANGE");
			_this1.historyParameters.push(0.09);
			_this1.historyParameters.push(0.1);
			_this1.historyParameters.push(-0.09);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_COLOR_CHANGE");
			_this1.turtleParameters.push(0.09);
			_this1.turtleParameters.push(0.1);
			_this1.turtleParameters.push(-0.09);
		} else {
			var c = _this1.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + 0.09) * 255) << 16 | Math.round((g0 + 0.1) * 255) << 8 | Math.round((b0 + (-0.09)) * 255);
		}
		var _this = _this1;
		_this.repeatCommands = false;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = _this.turtleHistoryOn;
		_this.turtleHistoryOn = false;
		var v = _this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = _this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = _this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = _this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARC");
						_this.historyParameters.push(radius);
						_this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARC");
							_this.turtleParameters.push(radius);
							_this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = _this.x;
							var oy = _this.y;
							var arr = [];
							arr.push(_this.x);
							arr.push(_this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								_this.rotation += rotate;
								var wasHistoryOn1 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength);
								} else {
									var nx = _this.x + baseLength * Math.cos(_this.rotation);
									var ny = _this.y + baseLength * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength;
										_this.lineTo(nx,ny);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx;
										_this.y = ny;
										var l = _this.points.length;
										_this.points[l] = [];
										_this.points[l][0] = nx;
										_this.points[l][1] = ny;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = _this.dim[_this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn1;
								if(_this.fill) {
									arr.push(_this.x);
									arr.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARCH_BEZIER");
						_this.historyParameters.push(distance);
						_this.historyParameters.push(distance2);
						_this.historyParameters.push(radius1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ARCH_BEZIER");
						_this.turtleParameters.push(distance);
						_this.turtleParameters.push(distance2);
						_this.turtleParameters.push(radius1);
					} else {
						var nx1 = _this.x + distance * Math.cos(_this.rotation);
						var ny1 = _this.y + distance * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (_this.x + nx1);
							var newy = 2 * thruY - 0.5 * (_this.y + ny1);
							_this.tempArr = [];
							var p = _this.tempArr;
							var ax = _this.x;
							var ay = _this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = _this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = x_;
								_this.y = y_;
								var l4 = _this.points.length;
								_this.points[l4] = [];
								_this.points[l4][0] = x_;
								_this.points[l4][1] = y_;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = _this.dim[_this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								_this.contour.reset();
							} else {
								_this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = _this.x;
							var oy1 = _this.y;
							while(i3 < l3) {
								if(_this.fill && _this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								_this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(_this.fill && _this.penIsDown) {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = ox1;
								_this.y = oy1;
								var l5 = _this.points.length;
								_this.points[l5] = [];
								_this.points[l5][0] = ox1;
								_this.points[l5][1] = oy1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = _this.dim[_this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								_this.contour.reset();
								_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							_this.x = nx1;
							_this.y = ny1;
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx1;
							_this.y = ny1;
							var l6 = _this.points.length;
							_this.points[l6] = [];
							_this.points[l6][0] = nx1;
							_this.points[l6][1] = ny1;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = _this.dim[_this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides == 24) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
						} else {
							_this.historyAdd("ARC_SIDES");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
							_this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(_this.repeatCommands) {
							if(sides == 24) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
							} else {
								_this.turtleCommands.push("ARC_SIDES");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
								_this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = _this.x;
							var oy2 = _this.y;
							var arr2 = [];
							arr2.push(_this.x);
							arr2.push(_this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								_this.rotation += rotate1;
								var wasHistoryOn2 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength1);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
									var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength1;
										_this.lineTo(nx2,ny2);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx2;
										_this.y = ny2;
										var l7 = _this.points.length;
										_this.points[l7] = [];
										_this.points[l7][0] = nx2;
										_this.points[l7][1] = ny2;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = _this.dim[_this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn2;
								if(_this.fill) {
									arr2.push(_this.x);
									arr2.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BACKWARD");
						_this.historyParameters.push(distance1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BACKWARD");
						_this.turtleParameters.push(distance1);
					} else {
						var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
						var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
						if(_this.penIsDown) {
							_this.lineTo(nx3,ny3);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx3;
							_this.y = ny3;
							var l9 = _this.points.length;
							_this.points[l9] = [];
							_this.points[l9][0] = nx3;
							_this.points[l9][1] = ny3;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = _this.dim[_this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLACK");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLACK");
					} else {
						_this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLUE");
					} else {
						_this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BROWN");
					} else {
						_this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CIRCLE");
						_this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CIRCLE");
							_this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = _this.x;
							var oy3 = _this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								_this.rotation += rotate2;
								var wasHistoryOn3 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength2);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
									var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength2;
										_this.lineTo(nx4,ny4);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx4;
										_this.y = ny4;
										var l10 = _this.points.length;
										_this.points[l10] = [];
										_this.points[l10][0] = nx4;
										_this.points[l10][1] = ny4;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = _this.dim[_this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn3;
								if(_this.fill) {
									arr3.push(_this.x);
									arr3.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides1 == 24) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius4);
						} else {
							_this.historyAdd("CIRCLE_SIDES");
							_this.historyParameters.push(radius4);
							_this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(_this.repeatCommands) {
							if(sides1 == 24) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius4);
							} else {
								_this.turtleCommands.push("CIRCLE_SIDES");
								_this.turtleParameters.push(radius4);
								_this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = _this.x;
							var oy4 = _this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								_this.rotation += rotate3;
								var wasHistoryOn4 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength3);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
									var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength3;
										_this.lineTo(nx5,ny5);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx5;
										_this.y = ny5;
										var l12 = _this.points.length;
										_this.points[l12] = [];
										_this.points[l12][0] = nx5;
										_this.points[l12][1] = ny5;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = _this.dim[_this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn4;
								if(_this.fill) {
									arr4.push(_this.x);
									arr4.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CYAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("CYAN");
					} else {
						_this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARKISH_BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARKISH_BLUE");
					} else {
						_this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARK_GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARK_GREEN");
					} else {
						_this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("EAST");
					} else {
						_this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_OFF");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_OFF");
					} else {
						_this.fill = false;
					}
					break;
				case "FILL_ON":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_ON");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_ON");
					} else {
						_this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD");
						_this.historyParameters.push(distance3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD");
						_this.turtleParameters.push(distance3);
					} else {
						var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
						var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance3;
							_this.lineTo(nx6,ny6);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx6;
							_this.y = ny6;
							var l14 = _this.points.length;
							_this.points[l14] = [];
							_this.points[l14][0] = nx6;
							_this.points[l14][1] = ny6;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = _this.dim[_this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_CHANGE");
						_this.historyParameters.push(deltaDistance);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_CHANGE");
						_this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = _this.lastDistance + deltaDistance;
						var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
						var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance4 + deltaDistance;
							_this.lineTo(nx7,ny7);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx7;
							_this.y = ny7;
							var l15 = _this.points.length;
							_this.points[l15] = [];
							_this.points[l15][0] = nx7;
							_this.points[l15][1] = ny7;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = _this.dim[_this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_FACTOR");
						_this.historyParameters.push(factor);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_FACTOR");
						_this.turtleParameters.push(factor);
					} else {
						var distance5 = _this.lastDistance * factor;
						var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
						var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance5;
							_this.lineTo(nx8,ny8);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx8;
							_this.y = ny8;
							var l16 = _this.points.length;
							_this.points[l16] = [];
							_this.points[l16][0] = nx8;
							_this.points[l16][1] = ny8;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = _this.dim[_this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREEN");
					} else {
						_this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREY");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREY");
					} else {
						_this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LEFT");
						_this.historyParameters.push(degrees2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LEFT");
						_this.turtleParameters.push(degrees2);
					} else {
						_this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LIGHT_BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LIGHT_BROWN");
					} else {
						_this.pen.currentColor = -3831790;
					}
					break;
				case "MAGENTA":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("MAGENTA");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MAGENTA");
					} else {
						_this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MOVE_PEN");
						_this.turtleParameters.push(distance6);
					} else if(_this.penIsDown) {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx9,ny9);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx9;
								_this.y = ny9;
								var l17 = _this.points.length;
								_this.points[l17] = [];
								_this.points[l17][0] = nx9;
								_this.points[l17][1] = ny9;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = _this.dim[_this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								_this.contour.reset();
							}
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
					} else {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx10,ny10);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx10;
								_this.y = ny10;
								var l18 = _this.points.length;
								_this.points[l18] = [];
								_this.points[l18][0] = nx10;
								_this.points[l18][1] = ny10;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = _this.dim[_this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								_this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("NORTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("NORTH");
					} else {
						_this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ORANGE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ORANGE");
					} else {
						_this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR");
						_this.historyParameters.push(r);
						_this.historyParameters.push(g);
						_this.historyParameters.push(b);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR");
						_this.turtleParameters.push(r);
						_this.turtleParameters.push(g);
						_this.turtleParameters.push(b);
					} else {
						_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_B");
						_this.historyParameters.push(r1);
						_this.historyParameters.push(g1);
						_this.historyParameters.push(b1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_B");
						_this.turtleParameters.push(r1);
						_this.turtleParameters.push(g1);
						_this.turtleParameters.push(b1);
					} else {
						_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_C");
						_this.historyParameters.push(r2);
						_this.historyParameters.push(g2);
						_this.historyParameters.push(b2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_C");
						_this.turtleParameters.push(r2);
						_this.turtleParameters.push(g2);
						_this.turtleParameters.push(b2);
					} else {
						_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE");
						_this.historyParameters.push(r3);
						_this.historyParameters.push(g3);
						_this.historyParameters.push(b3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE");
						_this.turtleParameters.push(r3);
						_this.turtleParameters.push(g3);
						_this.turtleParameters.push(b3);
					} else {
						var c = _this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_B");
						_this.historyParameters.push(r4);
						_this.historyParameters.push(g4);
						_this.historyParameters.push(b4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						_this.turtleParameters.push(r4);
						_this.turtleParameters.push(g4);
						_this.turtleParameters.push(b4);
					} else {
						var c1 = _this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_C");
						_this.historyParameters.push(r5);
						_this.historyParameters.push(g5);
						_this.historyParameters.push(b5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						_this.turtleParameters.push(r5);
						_this.turtleParameters.push(g5);
						_this.turtleParameters.push(b5);
					} else {
						var c2 = _this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_DOWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_DOWN");
					} else {
						_this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE");
						_this.historyParameters.push(w);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE");
						_this.turtleParameters.push(w);
					} else {
						_this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_CHANGE");
						_this.historyParameters.push(dw);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_CHANGE");
						_this.turtleParameters.push(dw);
					} else {
						_this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_FACTOR");
						_this.historyParameters.push(factor1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_FACTOR");
						_this.turtleParameters.push(factor1);
					} else {
						_this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_UP");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_UP");
					} else {
						_this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PLUM");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PLUM");
					} else {
						_this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RED");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RED");
					} else {
						_this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RIGHT");
						_this.historyParameters.push(degrees3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RIGHT");
						_this.turtleParameters.push(degrees3);
					} else {
						_this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_ANGLE");
						_this.historyParameters.push(degrees4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_ANGLE");
						_this.turtleParameters.push(degrees4);
					} else {
						_this.rotation = -Math.PI / 2;
						_this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_POSITION");
						_this.historyParameters.push(x2);
						_this.historyParameters.push(y2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_POSITION");
						_this.turtleParameters.push(x2);
						_this.turtleParameters.push(y2);
					} else {
						if(_this.endLine == 2 || _this.endLine == 3) {
							_this.contour.end(_this.width);
						}
						_this.x = x2;
						_this.y = y2;
						var l19 = _this.points.length;
						_this.points[l19] = [];
						_this.points[l19][0] = x2;
						_this.points[l19][1] = y2;
						_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
						_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
						_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = _this.dim[_this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						_this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SOUTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SOUTH");
					} else {
						_this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TAN");
					} else {
						_this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TRIANGLE_ARCH");
						_this.historyParameters.push(distance7);
						_this.historyParameters.push(distance21);
						_this.historyParameters.push(radius5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TRIANGLE_ARCH");
						_this.turtleParameters.push(distance7);
						_this.turtleParameters.push(distance21);
						_this.turtleParameters.push(radius5);
					} else {
						var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
						var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
							if(_this.fill) {
								_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
							}
							_this.lineTo(thruX1,thruY1);
							_this.lineTo(nx11,ny11);
							if(_this.fill) {
								_this.lineTo(_this.x,_this.y);
							}
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l20 = _this.points.length;
							_this.points[l20] = [];
							_this.points[l20][0] = nx11;
							_this.points[l20][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = _this.dim[_this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							_this.contour.reset();
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l21 = _this.points.length;
							_this.points[l21] = [];
							_this.points[l21][0] = nx11;
							_this.points[l21][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = _this.dim[_this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WEST");
					} else {
						_this.rotation = 0;
					}
					break;
				case "WHITE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WHITE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WHITE");
					} else {
						_this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("YELLOW");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("YELLOW");
					} else {
						_this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		_this.turtleHistoryOn = wasHistoryOn;
		_this.turtleCommands.length = 0;
		_this.turtleParameters.length = 0;
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BLUE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("BLUE");
		} else {
			_this1.pen.currentColor = -16776961;
		}
		var tmp = this.allRange;
		var ii_min = s;
		var ii_max = this.pen2D.arr[0] | 0;
		var this1 = new cornerContour_io_IntIterStart(ii_min,ii_max);
		tmp.push(this1);
	}
	,pentagram: function(x,y,size) {
		var sketcher = new cornerContour_Sketcher(this.pen2D,4,0);
		var sides = 5;
		var angle = 120.;
		var s = this.pen2D.arr[0] | 0;
		if(sketcher.turtleHistoryOn) {
			sketcher.historyAdd("SET_POSITION");
			sketcher.historyParameters.push(x);
			sketcher.historyParameters.push(y);
		}
		if(sketcher.repeatCommands) {
			sketcher.turtleCommands.push("SET_POSITION");
			sketcher.turtleParameters.push(x);
			sketcher.turtleParameters.push(y);
		} else {
			if(sketcher.endLine == 2 || sketcher.endLine == 3) {
				sketcher.contour.end(sketcher.width);
			}
			sketcher.x = x;
			sketcher.y = y;
			var l = sketcher.points.length;
			sketcher.points[l] = [];
			sketcher.points[l][0] = x;
			sketcher.points[l][1] = y;
			sketcher.pointsClock[sketcher.pointsClock.length] = sketcher.contour.pointsClock.slice();
			sketcher.pointsAnti[sketcher.pointsAnti.length] = sketcher.contour.pointsAnti.slice();
			sketcher.dim[sketcher.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
			var d = sketcher.dim[sketcher.dim.length - 1];
			if(x < d.minX) {
				d.minX = x;
			}
			if(x > d.maxX) {
				d.maxX = x;
			}
			if(y < d.minY) {
				d.minY = y;
			}
			if(y > d.maxY) {
				d.maxY = y;
			}
			sketcher.contour.reset();
		}
		var _this = sketcher;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("PEN_SIZE");
			_this.historyParameters.push(size);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("PEN_SIZE");
			_this.turtleParameters.push(size);
		} else {
			_this.width = size;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BLUE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("BLUE");
		} else {
			_this1.pen.currentColor = -16776961;
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("WEST");
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("WEST");
		} else {
			_this.rotation = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("FILL_OFF");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("FILL_OFF");
		} else {
			_this1.fill = false;
		}
		var _this = _this1;
		var repeatCount_ = sides + 1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("BEGIN_REPEAT");
			_this.historyParameters.push(Math.round(repeatCount_));
		}
		if(_this.repeatCommands == true) {
			_this.repeatCommands = false;
			if(_this.turtleHistoryOn) {
				_this.historyAdd("END_REPEAT");
			}
			var wasHistoryOn = _this.turtleHistoryOn;
			_this.turtleHistoryOn = false;
			var v = _this.turtleParameters;
			var j = 0;
			var _g = 0;
			var _g1 = _this.repeatCount;
			while(_g < _g1) {
				var k = _g++;
				var _g2 = 0;
				var _g3 = _this.turtleCommands.length;
				while(_g2 < _g3) {
					var i = _g2++;
					var command = _this.turtleCommands[i];
					switch(command) {
					case "ARC":
						var radius = v[j];
						var degrees = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius);
							_this.historyParameters.push(degrees);
						}
						if(radius != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius);
								_this.turtleParameters.push(degrees);
							} else {
								var beta = degrees * Math.PI / 180 / 24;
								var alpha = (Math.PI - beta) / 2;
								var rotate = -(Math.PI / 2 - alpha);
								var baseLength = 0.5 * radius * Math.sin(beta / 2);
								var ox = _this.x;
								var oy = _this.y;
								var arr = [];
								arr.push(_this.x);
								arr.push(_this.y);
								var _g4 = 0;
								while(_g4 < 48) {
									var i1 = _g4++;
									_this.rotation += rotate;
									var wasHistoryOn1 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength);
									} else {
										var nx = _this.x + baseLength * Math.cos(_this.rotation);
										var ny = _this.y + baseLength * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength;
											_this.lineTo(nx,ny);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx;
											_this.y = ny;
											var l = _this.points.length;
											_this.points[l] = [];
											_this.points[l][0] = nx;
											_this.points[l][1] = ny;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d = _this.dim[_this.dim.length - 1];
											if(nx < d.minX) {
												d.minX = nx;
											}
											if(nx > d.maxX) {
												d.maxX = nx;
											}
											if(ny < d.minY) {
												d.minY = ny;
											}
											if(ny > d.maxY) {
												d.maxY = ny;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn1;
									if(_this.fill) {
										arr.push(_this.x);
										arr.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx = (ox + arr[arr.length - 2]) / 2;
									var cy = (oy + arr[arr.length - 1]) / 2;
									var l1 = arr.length;
									var i2 = 2;
									var lx = 0.;
									var ly = 0.;
									_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
									while(i2 < l1) {
										if(i2 > 2) {
											_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
										}
										lx = arr[i2];
										ly = arr[i2 + 1];
										i2 += 2;
									}
								}
								arr.length = 0;
							}
						}
						j += 2;
						break;
					case "ARCH_BEZIER":
						var distance = v[j];
						var distance2 = v[j + 1];
						var radius1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ARCH_BEZIER");
							_this.historyParameters.push(distance);
							_this.historyParameters.push(distance2);
							_this.historyParameters.push(radius1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARCH_BEZIER");
							_this.turtleParameters.push(distance);
							_this.turtleParameters.push(distance2);
							_this.turtleParameters.push(radius1);
						} else {
							var nx1 = _this.x + distance * Math.cos(_this.rotation);
							var ny1 = _this.y + distance * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
								var newx = 2 * thruX - 0.5 * (_this.x + nx1);
								var newy = 2 * thruY - 0.5 * (_this.y + ny1);
								_this.tempArr = [];
								var p = _this.tempArr;
								var ax = _this.x;
								var ay = _this.y;
								var x = ax - newx;
								var y = ay - newy;
								var x1 = newx - nx1;
								var y1 = newy - ny1;
								var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
								if(approxDistance == 0) {
									approxDistance = 0.000001;
								}
								var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
								var l2 = p.length;
								p[l2++] = ax;
								p[l2++] = ay;
								var t = step;
								while(t < 1.) {
									var u = 1 - t;
									p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
									var u1 = 1 - t;
									p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
									t += step;
								}
								p[l2++] = nx1;
								p[l2++] = ny1;
								var arr1 = _this.tempArr;
								var withMove = false;
								if(withMove == null) {
									withMove = true;
								}
								var l3 = arr1.length;
								var i3 = 2;
								if(withMove) {
									var x_ = arr1[0];
									var y_ = arr1[1];
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = x_;
									_this.y = y_;
									var l4 = _this.points.length;
									_this.points[l4] = [];
									_this.points[l4][0] = x_;
									_this.points[l4][1] = y_;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d1 = _this.dim[_this.dim.length - 1];
									if(x_ < d1.minX) {
										d1.minX = x_;
									}
									if(x_ > d1.maxX) {
										d1.maxX = x_;
									}
									if(y_ < d1.minY) {
										d1.minY = y_;
									}
									if(y_ > d1.maxY) {
										d1.maxY = y_;
									}
									_this.contour.reset();
								} else {
									_this.lineTo(arr1[0],arr1[1]);
								}
								var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
								var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
								var ox1 = _this.x;
								var oy1 = _this.y;
								while(i3 < l3) {
									if(_this.fill && _this.penIsDown) {
										if(i3 > 0 && i3 < l3 - 2) {
											_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
										}
									}
									_this.lineTo(arr1[i3],arr1[i3 + 1]);
									i3 += 2;
								}
								if(_this.fill && _this.penIsDown) {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = ox1;
									_this.y = oy1;
									var l5 = _this.points.length;
									_this.points[l5] = [];
									_this.points[l5][0] = ox1;
									_this.points[l5][1] = oy1;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d2 = _this.dim[_this.dim.length - 1];
									if(ox1 < d2.minX) {
										d2.minX = ox1;
									}
									if(ox1 > d2.maxX) {
										d2.maxX = ox1;
									}
									if(oy1 < d2.minY) {
										d2.minY = oy1;
									}
									if(oy1 > d2.maxY) {
										d2.maxY = oy1;
									}
									_this.contour.reset();
									_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
								}
								_this.x = nx1;
								_this.y = ny1;
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx1;
								_this.y = ny1;
								var l6 = _this.points.length;
								_this.points[l6] = [];
								_this.points[l6][0] = nx1;
								_this.points[l6][1] = ny1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d3 = _this.dim[_this.dim.length - 1];
								if(nx1 < d3.minX) {
									d3.minX = nx1;
								}
								if(nx1 > d3.maxX) {
									d3.maxX = nx1;
								}
								if(ny1 < d3.minY) {
									d3.minY = ny1;
								}
								if(ny1 > d3.maxY) {
									d3.maxY = ny1;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "ARC_SIDES":
						var radius2 = v[j];
						var degrees1 = v[j + 1];
						var sides = v[j + 2];
						if(sides == null) {
							sides = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides == 24) {
								_this.historyAdd("ARC");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
							} else {
								_this.historyAdd("ARC_SIDES");
								_this.historyParameters.push(radius2);
								_this.historyParameters.push(degrees1);
								_this.historyParameters.push(sides);
							}
						}
						if(radius2 != 0) {
							if(_this.repeatCommands) {
								if(sides == 24) {
									_this.turtleCommands.push("ARC");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
								} else {
									_this.turtleCommands.push("ARC_SIDES");
									_this.turtleParameters.push(radius2);
									_this.turtleParameters.push(degrees1);
									_this.turtleParameters.push(sides);
								}
							} else {
								var beta1 = degrees1 * Math.PI / 180 / sides;
								var alpha1 = (Math.PI - beta1) / 2;
								var rotate1 = -(Math.PI / 2 - alpha1);
								var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
								var ox2 = _this.x;
								var oy2 = _this.y;
								var arr2 = [];
								arr2.push(_this.x);
								arr2.push(_this.y);
								var _g5 = 0;
								while(_g5 < 48) {
									var i4 = _g5++;
									_this.rotation += rotate1;
									var wasHistoryOn2 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength1);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength1);
									} else {
										var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
										var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength1;
											_this.lineTo(nx2,ny2);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx2;
											_this.y = ny2;
											var l7 = _this.points.length;
											_this.points[l7] = [];
											_this.points[l7][0] = nx2;
											_this.points[l7][1] = ny2;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d4 = _this.dim[_this.dim.length - 1];
											if(nx2 < d4.minX) {
												d4.minX = nx2;
											}
											if(nx2 > d4.maxX) {
												d4.maxX = nx2;
											}
											if(ny2 < d4.minY) {
												d4.minY = ny2;
											}
											if(ny2 > d4.maxY) {
												d4.maxY = ny2;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn2;
									if(_this.fill) {
										arr2.push(_this.x);
										arr2.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
									var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
									var l8 = arr2.length;
									var i5 = 2;
									var lx1 = 0.;
									var ly1 = 0.;
									_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
									while(i5 < l8) {
										if(i5 > 2) {
											_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
										}
										lx1 = arr2[i5];
										ly1 = arr2[i5 + 1];
										i5 += 2;
									}
								}
								arr2.length = 0;
							}
						}
						j += 3;
						break;
					case "BACKWARD":
						var distance1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BACKWARD");
							_this.historyParameters.push(distance1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BACKWARD");
							_this.turtleParameters.push(distance1);
						} else {
							var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
							var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
							if(_this.penIsDown) {
								_this.lineTo(nx3,ny3);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx3;
								_this.y = ny3;
								var l9 = _this.points.length;
								_this.points[l9] = [];
								_this.points[l9][0] = nx3;
								_this.points[l9][1] = ny3;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d5 = _this.dim[_this.dim.length - 1];
								if(nx3 < d5.minX) {
									d5.minX = nx3;
								}
								if(nx3 > d5.maxX) {
									d5.maxX = nx3;
								}
								if(ny3 < d5.minY) {
									d5.minY = ny3;
								}
								if(ny3 > d5.maxY) {
									d5.maxY = ny3;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "BEGIN_REPEAT":
						break;
					case "BLACK":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLACK");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLACK");
						} else {
							_this.pen.currentColor = -16777216;
						}
						break;
					case "BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BLUE");
						} else {
							_this.pen.currentColor = -16776961;
						}
						break;
					case "BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("BROWN");
						} else {
							_this.pen.currentColor = -6594501;
						}
						break;
					case "CIRCLE":
						var radius3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius3);
						}
						if(radius3 != 0) {
							if(_this.repeatCommands) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius3);
							} else {
								var beta2 = 2 * Math.PI / 24;
								var alpha2 = (Math.PI - beta2) / 2;
								var rotate2 = -(Math.PI / 2 - alpha2);
								var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
								var ox3 = _this.x;
								var oy3 = _this.y;
								var arr3 = [];
								var _g6 = 0;
								while(_g6 < 48) {
									var i6 = _g6++;
									_this.rotation += rotate2;
									var wasHistoryOn3 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength2);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength2);
									} else {
										var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
										var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength2;
											_this.lineTo(nx4,ny4);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx4;
											_this.y = ny4;
											var l10 = _this.points.length;
											_this.points[l10] = [];
											_this.points[l10][0] = nx4;
											_this.points[l10][1] = ny4;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d6 = _this.dim[_this.dim.length - 1];
											if(nx4 < d6.minX) {
												d6.minX = nx4;
											}
											if(nx4 > d6.maxX) {
												d6.maxX = nx4;
											}
											if(ny4 < d6.minY) {
												d6.minY = ny4;
											}
											if(ny4 > d6.maxY) {
												d6.maxY = ny4;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn3;
									if(_this.fill) {
										arr3.push(_this.x);
										arr3.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
									var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
									var l11 = arr3.length;
									var i7 = 2;
									var lx2 = 0.;
									var ly2 = 0.;
									while(i7 < l11) {
										if(i7 > 2) {
											_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
										}
										lx2 = arr3[i7];
										ly2 = arr3[i7 + 1];
										i7 += 2;
									}
								}
								arr3.length = 0;
							}
						}
						++j;
						break;
					case "CIRCLE_SIDES":
						var radius4 = v[j];
						var sides1 = v[j + 1];
						if(sides1 == null) {
							sides1 = 24;
						}
						if(_this.turtleHistoryOn) {
							if(sides1 == 24) {
								_this.historyAdd("CIRCLE");
								_this.historyParameters.push(radius4);
							} else {
								_this.historyAdd("CIRCLE_SIDES");
								_this.historyParameters.push(radius4);
								_this.historyParameters.push(sides1);
							}
						}
						if(radius4 != 0) {
							if(_this.repeatCommands) {
								if(sides1 == 24) {
									_this.turtleCommands.push("CIRCLE");
									_this.turtleParameters.push(radius4);
								} else {
									_this.turtleCommands.push("CIRCLE_SIDES");
									_this.turtleParameters.push(radius4);
									_this.turtleParameters.push(sides1);
								}
							} else {
								var beta3 = 2 * Math.PI / sides1;
								var alpha3 = (Math.PI - beta3) / 2;
								var rotate3 = -(Math.PI / 2 - alpha3);
								var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
								var ox4 = _this.x;
								var oy4 = _this.y;
								var arr4 = [];
								var _g7 = 0;
								while(_g7 < 48) {
									var i8 = _g7++;
									_this.rotation += rotate3;
									var wasHistoryOn4 = _this.turtleHistoryOn;
									_this.turtleHistoryOn = false;
									if(_this.turtleHistoryOn) {
										_this.historyAdd("FORWARD");
										_this.historyParameters.push(baseLength3);
									}
									if(_this.repeatCommands) {
										_this.turtleCommands.push("FORWARD");
										_this.turtleParameters.push(baseLength3);
									} else {
										var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
										var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
										if(_this.penIsDown) {
											_this.lastDistance = baseLength3;
											_this.lineTo(nx5,ny5);
										} else {
											if(_this.endLine == 2 || _this.endLine == 3) {
												_this.contour.end(_this.width);
											}
											_this.x = nx5;
											_this.y = ny5;
											var l12 = _this.points.length;
											_this.points[l12] = [];
											_this.points[l12][0] = nx5;
											_this.points[l12][1] = ny5;
											_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
											_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
											_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
											var d7 = _this.dim[_this.dim.length - 1];
											if(nx5 < d7.minX) {
												d7.minX = nx5;
											}
											if(nx5 > d7.maxX) {
												d7.maxX = nx5;
											}
											if(ny5 < d7.minY) {
												d7.minY = ny5;
											}
											if(ny5 > d7.maxY) {
												d7.maxY = ny5;
											}
											_this.contour.reset();
										}
									}
									_this.turtleHistoryOn = wasHistoryOn4;
									if(_this.fill) {
										arr4.push(_this.x);
										arr4.push(_this.y);
									}
								}
								if(_this.fill) {
									var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
									var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
									var l13 = arr4.length;
									var i9 = 2;
									var lx3 = 0.;
									var ly3 = 0.;
									while(i9 < l13) {
										if(i9 > 2) {
											_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
										}
										lx3 = arr4[i9];
										ly3 = arr4[i9 + 1];
										i9 += 2;
									}
								}
								arr4.length = 0;
							}
						}
						j += 2;
						break;
					case "CYAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("CYAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CYAN");
						} else {
							_this.pen.currentColor = -16711681;
						}
						break;
					case "DARKISH_BLUE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARKISH_BLUE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARKISH_BLUE");
						} else {
							_this.pen.currentColor = -8864837;
						}
						break;
					case "DARK_GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("DARK_GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("DARK_GREEN");
						} else {
							_this.pen.currentColor = -10182080;
						}
						break;
					case "EAST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("EAST");
						} else {
							_this.rotation = Math.PI;
						}
						break;
					case "END_REPEAT":
						break;
					case "FILL_OFF":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_OFF");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_OFF");
						} else {
							_this.fill = false;
						}
						break;
					case "FILL_ON":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FILL_ON");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FILL_ON");
						} else {
							_this.fill = true;
						}
						break;
					case "FORWARD":
						var distance3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance3);
						} else {
							var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
							var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance3;
								_this.lineTo(nx6,ny6);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx6;
								_this.y = ny6;
								var l14 = _this.points.length;
								_this.points[l14] = [];
								_this.points[l14][0] = nx6;
								_this.points[l14][1] = ny6;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d8 = _this.dim[_this.dim.length - 1];
								if(nx6 < d8.minX) {
									d8.minX = nx6;
								}
								if(nx6 > d8.maxX) {
									d8.maxX = nx6;
								}
								if(ny6 < d8.minY) {
									d8.minY = ny6;
								}
								if(ny6 > d8.maxY) {
									d8.maxY = ny6;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_CHANGE":
						var deltaDistance = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_CHANGE");
							_this.historyParameters.push(deltaDistance);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_CHANGE");
							_this.turtleParameters.push(deltaDistance);
						} else {
							var distance4 = _this.lastDistance + deltaDistance;
							var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
							var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance4 + deltaDistance;
								_this.lineTo(nx7,ny7);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx7;
								_this.y = ny7;
								var l15 = _this.points.length;
								_this.points[l15] = [];
								_this.points[l15][0] = nx7;
								_this.points[l15][1] = ny7;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d9 = _this.dim[_this.dim.length - 1];
								if(nx7 < d9.minX) {
									d9.minX = nx7;
								}
								if(nx7 > d9.maxX) {
									d9.maxX = nx7;
								}
								if(ny7 < d9.minY) {
									d9.minY = ny7;
								}
								if(ny7 > d9.maxY) {
									d9.maxY = ny7;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "FORWARD_FACTOR":
						var factor = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD_FACTOR");
							_this.historyParameters.push(factor);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD_FACTOR");
							_this.turtleParameters.push(factor);
						} else {
							var distance5 = _this.lastDistance * factor;
							var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
							var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance5;
								_this.lineTo(nx8,ny8);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx8;
								_this.y = ny8;
								var l16 = _this.points.length;
								_this.points[l16] = [];
								_this.points[l16][0] = nx8;
								_this.points[l16][1] = ny8;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d10 = _this.dim[_this.dim.length - 1];
								if(nx8 < d10.minX) {
									d10.minX = nx8;
								}
								if(nx8 > d10.maxX) {
									d10.maxX = nx8;
								}
								if(ny8 < d10.minY) {
									d10.minY = ny8;
								}
								if(ny8 > d10.maxY) {
									d10.maxY = ny8;
								}
								_this.contour.reset();
							}
						}
						++j;
						break;
					case "GREEN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREEN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREEN");
						} else {
							_this.pen.currentColor = -16711936;
						}
						break;
					case "GREY":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("GREY");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("GREY");
						} else {
							_this.pen.currentColor = -4737097;
						}
						break;
					case "LEFT":
						var degrees2 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LEFT");
							_this.historyParameters.push(degrees2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LEFT");
							_this.turtleParameters.push(degrees2);
						} else {
							_this.rotation -= degrees2 * Math.PI / 180;
						}
						++j;
						break;
					case "LIGHT_BROWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("LIGHT_BROWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("LIGHT_BROWN");
						} else {
							_this.pen.currentColor = -3831790;
						}
						break;
					case "MAGENTA":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("MAGENTA");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MAGENTA");
						} else {
							_this.pen.currentColor = -65281;
						}
						break;
					case "MOVE_PEN":
						var distance6 = v[j];
						if(_this.repeatCommands) {
							_this.turtleCommands.push("MOVE_PEN");
							_this.turtleParameters.push(distance6);
						} else if(_this.penIsDown) {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_UP");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_UP");
							} else {
								_this.penIsDown = false;
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx9,ny9);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx9;
									_this.y = ny9;
									var l17 = _this.points.length;
									_this.points[l17] = [];
									_this.points[l17][0] = nx9;
									_this.points[l17][1] = ny9;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d11 = _this.dim[_this.dim.length - 1];
									if(nx9 < d11.minX) {
										d11.minX = nx9;
									}
									if(nx9 > d11.maxX) {
										d11.maxX = nx9;
									}
									if(ny9 < d11.minY) {
										d11.minY = ny9;
									}
									if(ny9 > d11.maxY) {
										d11.maxY = ny9;
									}
									_this.contour.reset();
								}
							}
							if(_this.turtleHistoryOn) {
								_this.historyAdd("PEN_DOWN");
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("PEN_DOWN");
							} else {
								_this.penIsDown = true;
							}
						} else {
							if(_this.turtleHistoryOn) {
								_this.historyAdd("FORWARD");
								_this.historyParameters.push(distance6);
							}
							if(_this.repeatCommands) {
								_this.turtleCommands.push("FORWARD");
								_this.turtleParameters.push(distance6);
							} else {
								var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
								var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
								if(_this.penIsDown) {
									_this.lastDistance = distance6;
									_this.lineTo(nx10,ny10);
								} else {
									if(_this.endLine == 2 || _this.endLine == 3) {
										_this.contour.end(_this.width);
									}
									_this.x = nx10;
									_this.y = ny10;
									var l18 = _this.points.length;
									_this.points[l18] = [];
									_this.points[l18][0] = nx10;
									_this.points[l18][1] = ny10;
									_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
									_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
									_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
									var d12 = _this.dim[_this.dim.length - 1];
									if(nx10 < d12.minX) {
										d12.minX = nx10;
									}
									if(nx10 > d12.maxX) {
										d12.maxX = nx10;
									}
									if(ny10 < d12.minY) {
										d12.minY = ny10;
									}
									if(ny10 > d12.maxY) {
										d12.maxY = ny10;
									}
									_this.contour.reset();
								}
							}
						}
						++j;
						break;
					case "NORTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("NORTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("NORTH");
						} else {
							_this.rotation = -Math.PI / 2;
						}
						break;
					case "ORANGE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("ORANGE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ORANGE");
						} else {
							_this.pen.currentColor = -23808;
						}
						break;
					case "PEN_COLOR":
						var r = v[j];
						var g = v[j + 1];
						var b = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR");
							_this.historyParameters.push(r);
							_this.historyParameters.push(g);
							_this.historyParameters.push(b);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR");
							_this.turtleParameters.push(r);
							_this.turtleParameters.push(g);
							_this.turtleParameters.push(b);
						} else {
							_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_B":
						var r1 = v[j];
						var g1 = v[j + 1];
						var b1 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_B");
							_this.historyParameters.push(r1);
							_this.historyParameters.push(g1);
							_this.historyParameters.push(b1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_B");
							_this.turtleParameters.push(r1);
							_this.turtleParameters.push(g1);
							_this.turtleParameters.push(b1);
						} else {
							_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_C":
						var r2 = v[j];
						var g2 = v[j + 1];
						var b2 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_C");
							_this.historyParameters.push(r2);
							_this.historyParameters.push(g2);
							_this.historyParameters.push(b2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_C");
							_this.turtleParameters.push(r2);
							_this.turtleParameters.push(g2);
							_this.turtleParameters.push(b2);
						} else {
							_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE":
						var r3 = v[j];
						var g3 = v[j + 1];
						var b3 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE");
							_this.historyParameters.push(r3);
							_this.historyParameters.push(g3);
							_this.historyParameters.push(b3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE");
							_this.turtleParameters.push(r3);
							_this.turtleParameters.push(g3);
							_this.turtleParameters.push(b3);
						} else {
							var c = _this.pen.currentColor;
							var r0 = (c >> 16 & 255) / 255;
							var g0 = (c >> 8 & 255) / 255;
							var b0 = (c & 255) / 255;
							_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_B":
						var r4 = v[j];
						var g4 = v[j + 1];
						var b4 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_B");
							_this.historyParameters.push(r4);
							_this.historyParameters.push(g4);
							_this.historyParameters.push(b4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
							_this.turtleParameters.push(r4);
							_this.turtleParameters.push(g4);
							_this.turtleParameters.push(b4);
						} else {
							var c1 = _this.pen.colorB;
							var r01 = (c1 >> 16 & 255) / 255;
							var g01 = (c1 >> 8 & 255) / 255;
							var b01 = (c1 & 255) / 255;
							_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
						}
						j += 3;
						break;
					case "PEN_COLOR_CHANGE_C":
						var r5 = v[j];
						var g5 = v[j + 1];
						var b5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_COLOR_CHANGE_C");
							_this.historyParameters.push(r5);
							_this.historyParameters.push(g5);
							_this.historyParameters.push(b5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
							_this.turtleParameters.push(r5);
							_this.turtleParameters.push(g5);
							_this.turtleParameters.push(b5);
						} else {
							var c2 = _this.pen.colorC;
							var r02 = (c2 >> 16 & 255) / 255;
							var g02 = (c2 >> 8 & 255) / 255;
							var b02 = (c2 & 255) / 255;
							_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
						}
						j += 3;
						break;
					case "PEN_DOWN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
						break;
					case "PEN_SIZE":
						var w = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE");
							_this.historyParameters.push(w);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE");
							_this.turtleParameters.push(w);
						} else {
							_this.width = w;
						}
						++j;
						break;
					case "PEN_SIZE_CHANGE":
						var dw = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_CHANGE");
							_this.historyParameters.push(dw);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_CHANGE");
							_this.turtleParameters.push(dw);
						} else {
							_this.width += dw;
						}
						++j;
						break;
					case "PEN_SIZE_FACTOR":
						var factor1 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_SIZE_FACTOR");
							_this.historyParameters.push(factor1);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_SIZE_FACTOR");
							_this.turtleParameters.push(factor1);
						} else {
							_this.width *= factor1;
						}
						++j;
						break;
					case "PEN_UP":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						break;
					case "PLUM":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PLUM");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PLUM");
						} else {
							_this.pen.currentColor = -7310896;
						}
						break;
					case "RED":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RED");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RED");
						} else {
							_this.pen.currentColor = -65536;
						}
						break;
					case "RIGHT":
						var degrees3 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("RIGHT");
							_this.historyParameters.push(degrees3);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("RIGHT");
							_this.turtleParameters.push(degrees3);
						} else {
							_this.rotation += degrees3 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_ANGLE":
						var degrees4 = v[j];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_ANGLE");
							_this.historyParameters.push(degrees4);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_ANGLE");
							_this.turtleParameters.push(degrees4);
						} else {
							_this.rotation = -Math.PI / 2;
							_this.rotation += degrees4 * Math.PI / 180;
						}
						++j;
						break;
					case "SET_POSITION":
						var x2 = v[j];
						var y2 = v[j + 1];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SET_POSITION");
							_this.historyParameters.push(x2);
							_this.historyParameters.push(y2);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SET_POSITION");
							_this.turtleParameters.push(x2);
							_this.turtleParameters.push(y2);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = x2;
							_this.y = y2;
							var l19 = _this.points.length;
							_this.points[l19] = [];
							_this.points[l19][0] = x2;
							_this.points[l19][1] = y2;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d13 = _this.dim[_this.dim.length - 1];
							if(x2 < d13.minX) {
								d13.minX = x2;
							}
							if(x2 > d13.maxX) {
								d13.maxX = x2;
							}
							if(y2 < d13.minY) {
								d13.minY = y2;
							}
							if(y2 > d13.maxY) {
								d13.maxY = y2;
							}
							_this.contour.reset();
						}
						j += 2;
						break;
					case "SOUTH":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("SOUTH");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("SOUTH");
						} else {
							_this.rotation = Math.PI / 2;
						}
						break;
					case "TAN":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TAN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TAN");
						} else {
							_this.pen.currentColor = -27273;
						}
						break;
					case "TRIANGLE_ARCH":
						var distance7 = v[j];
						var distance21 = v[j + 1];
						var radius5 = v[j + 2];
						if(_this.turtleHistoryOn) {
							_this.historyAdd("TRIANGLE_ARCH");
							_this.historyParameters.push(distance7);
							_this.historyParameters.push(distance21);
							_this.historyParameters.push(radius5);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("TRIANGLE_ARCH");
							_this.turtleParameters.push(distance7);
							_this.turtleParameters.push(distance21);
							_this.turtleParameters.push(radius5);
						} else {
							var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
							var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
								var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
								if(_this.fill) {
									_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
								}
								_this.lineTo(thruX1,thruY1);
								_this.lineTo(nx11,ny11);
								if(_this.fill) {
									_this.lineTo(_this.x,_this.y);
								}
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l20 = _this.points.length;
								_this.points[l20] = [];
								_this.points[l20][0] = nx11;
								_this.points[l20][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d14 = _this.dim[_this.dim.length - 1];
								if(nx11 < d14.minX) {
									d14.minX = nx11;
								}
								if(nx11 > d14.maxX) {
									d14.maxX = nx11;
								}
								if(ny11 < d14.minY) {
									d14.minY = ny11;
								}
								if(ny11 > d14.maxY) {
									d14.maxY = ny11;
								}
								_this.contour.reset();
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx11;
								_this.y = ny11;
								var l21 = _this.points.length;
								_this.points[l21] = [];
								_this.points[l21][0] = nx11;
								_this.points[l21][1] = ny11;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d15 = _this.dim[_this.dim.length - 1];
								if(nx11 < d15.minX) {
									d15.minX = nx11;
								}
								if(nx11 > d15.maxX) {
									d15.maxX = nx11;
								}
								if(ny11 < d15.minY) {
									d15.minY = ny11;
								}
								if(ny11 > d15.maxY) {
									d15.maxY = ny11;
								}
								_this.contour.reset();
							}
						}
						j += 3;
						break;
					case "WEST":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WEST");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WEST");
						} else {
							_this.rotation = 0;
						}
						break;
					case "WHITE":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("WHITE");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("WHITE");
						} else {
							_this.pen.currentColor = -1;
						}
						break;
					case "YELLOW":
						if(_this.turtleHistoryOn) {
							_this.historyAdd("YELLOW");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("YELLOW");
						} else {
							_this.pen.currentColor = -256;
						}
						break;
					}
				}
				j = 0;
			}
			_this.turtleHistoryOn = wasHistoryOn;
			_this.turtleCommands.length = 0;
			_this.turtleParameters.length = 0;
		}
		if(repeatCount_ > 0) {
			_this.repeatCount = Math.round(repeatCount_);
			_this.repeatCommands = true;
			_this.turtleCommands.length = 0;
			_this.turtleParameters.length = 0;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("ARCH_BEZIER");
			_this1.historyParameters.push(300);
			_this1.historyParameters.push(150);
			_this1.historyParameters.push(30);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("ARCH_BEZIER");
			_this1.turtleParameters.push(300);
			_this1.turtleParameters.push(150);
			_this1.turtleParameters.push(30);
		} else {
			var nx = _this1.x + 300 * Math.cos(_this1.rotation);
			var ny = _this1.y + 300 * Math.sin(_this1.rotation);
			if(_this1.penIsDown) {
				var thruX = _this1.x + 150 * Math.cos(_this1.rotation) - 30 * Math.cos(_this1.rotation + Math.PI / 2);
				var thruY = _this1.y + 150 * Math.sin(_this1.rotation) - 30 * Math.sin(_this1.rotation + Math.PI / 2);
				var newx = 2 * thruX - 0.5 * (_this1.x + nx);
				var newy = 2 * thruY - 0.5 * (_this1.y + ny);
				_this1.tempArr = [];
				var p = _this1.tempArr;
				var ax = _this1.x;
				var ay = _this1.y;
				var x = ax - newx;
				var y = ay - newy;
				var x1 = newx - nx;
				var y1 = newy - ny;
				var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
				if(approxDistance == 0) {
					approxDistance = 0.000001;
				}
				var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
				var l = p.length;
				p[l++] = ax;
				p[l++] = ay;
				var t = step;
				while(t < 1.) {
					var u = 1 - t;
					p[l++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx;
					var u1 = 1 - t;
					p[l++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny;
					t += step;
				}
				p[l++] = nx;
				p[l++] = ny;
				var arr = _this1.tempArr;
				var withMove = false;
				if(withMove == null) {
					withMove = true;
				}
				var l = arr.length;
				var i = 2;
				if(withMove) {
					var x_ = arr[0];
					var y_ = arr[1];
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = x_;
					_this1.y = y_;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = x_;
					_this1.points[l1][1] = y_;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(x_ < d.minX) {
						d.minX = x_;
					}
					if(x_ > d.maxX) {
						d.maxX = x_;
					}
					if(y_ < d.minY) {
						d.minY = y_;
					}
					if(y_ > d.maxY) {
						d.maxY = y_;
					}
					_this1.contour.reset();
				} else {
					_this1.lineTo(arr[0],arr[1]);
				}
				var cx = (arr[0] + arr[l - 2]) / 2;
				var cy = (arr[1] + arr[l - 1]) / 2;
				var ox = _this1.x;
				var oy = _this1.y;
				while(i < l) {
					if(_this1.fill && _this1.penIsDown) {
						if(i > 0 && i < l - 2) {
							_this1.pen.triangle2DFill(arr[i - 2],arr[i - 1],arr[i],arr[i + 1],cx,cy);
						}
					}
					_this1.lineTo(arr[i],arr[i + 1]);
					i += 2;
				}
				if(_this1.fill && _this1.penIsDown) {
					if(_this1.endLine == 2 || _this1.endLine == 3) {
						_this1.contour.end(_this1.width);
					}
					_this1.x = ox;
					_this1.y = oy;
					var l1 = _this1.points.length;
					_this1.points[l1] = [];
					_this1.points[l1][0] = ox;
					_this1.points[l1][1] = oy;
					_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
					_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
					_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
					var d = _this1.dim[_this1.dim.length - 1];
					if(ox < d.minX) {
						d.minX = ox;
					}
					if(ox > d.maxX) {
						d.maxX = ox;
					}
					if(oy < d.minY) {
						d.minY = oy;
					}
					if(oy > d.maxY) {
						d.maxY = oy;
					}
					_this1.contour.reset();
					_this1.lineTo(arr[l - 2],arr[l - 1]);
				}
				_this1.x = nx;
				_this1.y = ny;
			} else {
				if(_this1.endLine == 2 || _this1.endLine == 3) {
					_this1.contour.end(_this1.width);
				}
				_this1.x = nx;
				_this1.y = ny;
				var l = _this1.points.length;
				_this1.points[l] = [];
				_this1.points[l][0] = nx;
				_this1.points[l][1] = ny;
				_this1.pointsClock[_this1.pointsClock.length] = _this1.contour.pointsClock.slice();
				_this1.pointsAnti[_this1.pointsAnti.length] = _this1.contour.pointsAnti.slice();
				_this1.dim[_this1.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
				var d = _this1.dim[_this1.dim.length - 1];
				if(nx < d.minX) {
					d.minX = nx;
				}
				if(nx > d.maxX) {
					d.maxX = nx;
				}
				if(ny < d.minY) {
					d.minY = ny;
				}
				if(ny > d.maxY) {
					d.maxY = ny;
				}
				_this1.contour.reset();
			}
		}
		var _this = _this1;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("RIGHT");
			_this.historyParameters.push(144);
		}
		if(_this.repeatCommands) {
			_this.turtleCommands.push("RIGHT");
			_this.turtleParameters.push(144);
		} else {
			_this.rotation += 144 * Math.PI / 180;
		}
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("PEN_COLOR_CHANGE");
			_this1.historyParameters.push(0.09);
			_this1.historyParameters.push(0.1);
			_this1.historyParameters.push(-0.09);
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("PEN_COLOR_CHANGE");
			_this1.turtleParameters.push(0.09);
			_this1.turtleParameters.push(0.1);
			_this1.turtleParameters.push(-0.09);
		} else {
			var c = _this1.pen.currentColor;
			var r0 = (c >> 16 & 255) / 255;
			var g0 = (c >> 8 & 255) / 255;
			var b0 = (c & 255) / 255;
			_this1.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + 0.09) * 255) << 16 | Math.round((g0 + 0.1) * 255) << 8 | Math.round((b0 + (-0.09)) * 255);
		}
		var _this = _this1;
		_this.repeatCommands = false;
		if(_this.turtleHistoryOn) {
			_this.historyAdd("END_REPEAT");
		}
		var wasHistoryOn = _this.turtleHistoryOn;
		_this.turtleHistoryOn = false;
		var v = _this.turtleParameters;
		var j = 0;
		var _g = 0;
		var _g1 = _this.repeatCount;
		while(_g < _g1) {
			var k = _g++;
			var _g2 = 0;
			var _g3 = _this.turtleCommands.length;
			while(_g2 < _g3) {
				var i = _g2++;
				var command = _this.turtleCommands[i];
				switch(command) {
				case "ARC":
					var radius = v[j];
					var degrees = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARC");
						_this.historyParameters.push(radius);
						_this.historyParameters.push(degrees);
					}
					if(radius != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("ARC");
							_this.turtleParameters.push(radius);
							_this.turtleParameters.push(degrees);
						} else {
							var beta = degrees * Math.PI / 180 / 24;
							var alpha = (Math.PI - beta) / 2;
							var rotate = -(Math.PI / 2 - alpha);
							var baseLength = 0.5 * radius * Math.sin(beta / 2);
							var ox = _this.x;
							var oy = _this.y;
							var arr = [];
							arr.push(_this.x);
							arr.push(_this.y);
							var _g4 = 0;
							while(_g4 < 48) {
								var i1 = _g4++;
								_this.rotation += rotate;
								var wasHistoryOn1 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength);
								} else {
									var nx = _this.x + baseLength * Math.cos(_this.rotation);
									var ny = _this.y + baseLength * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength;
										_this.lineTo(nx,ny);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx;
										_this.y = ny;
										var l = _this.points.length;
										_this.points[l] = [];
										_this.points[l][0] = nx;
										_this.points[l][1] = ny;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d = _this.dim[_this.dim.length - 1];
										if(nx < d.minX) {
											d.minX = nx;
										}
										if(nx > d.maxX) {
											d.maxX = nx;
										}
										if(ny < d.minY) {
											d.minY = ny;
										}
										if(ny > d.maxY) {
											d.maxY = ny;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn1;
								if(_this.fill) {
									arr.push(_this.x);
									arr.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx = (ox + arr[arr.length - 2]) / 2;
								var cy = (oy + arr[arr.length - 1]) / 2;
								var l1 = arr.length;
								var i2 = 2;
								var lx = 0.;
								var ly = 0.;
								_this.pen.triangle2DFill(ox,oy,arr[0],arr[1],cx,cy);
								while(i2 < l1) {
									if(i2 > 2) {
										_this.pen.triangle2DFill(lx,ly,arr[i2],arr[i2 + 1],cx,cy);
									}
									lx = arr[i2];
									ly = arr[i2 + 1];
									i2 += 2;
								}
							}
							arr.length = 0;
						}
					}
					j += 2;
					break;
				case "ARCH_BEZIER":
					var distance = v[j];
					var distance2 = v[j + 1];
					var radius1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ARCH_BEZIER");
						_this.historyParameters.push(distance);
						_this.historyParameters.push(distance2);
						_this.historyParameters.push(radius1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ARCH_BEZIER");
						_this.turtleParameters.push(distance);
						_this.turtleParameters.push(distance2);
						_this.turtleParameters.push(radius1);
					} else {
						var nx1 = _this.x + distance * Math.cos(_this.rotation);
						var ny1 = _this.y + distance * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX = _this.x + distance2 * Math.cos(_this.rotation) - radius1 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY = _this.y + distance2 * Math.sin(_this.rotation) - radius1 * Math.sin(_this.rotation + Math.PI / 2);
							var newx = 2 * thruX - 0.5 * (_this.x + nx1);
							var newy = 2 * thruY - 0.5 * (_this.y + ny1);
							_this.tempArr = [];
							var p = _this.tempArr;
							var ax = _this.x;
							var ay = _this.y;
							var x = ax - newx;
							var y = ay - newy;
							var x1 = newx - nx1;
							var y1 = newy - ny1;
							var approxDistance = Math.sqrt(x * x + y * y) + Math.sqrt(x1 * x1 + y1 * y1);
							if(approxDistance == 0) {
								approxDistance = 0.000001;
							}
							var step = Math.min(1 / (approxDistance * 0.707),cornerContour_CurveMath_quadStep);
							var l2 = p.length;
							p[l2++] = ax;
							p[l2++] = ay;
							var t = step;
							while(t < 1.) {
								var u = 1 - t;
								p[l2++] = Math.pow(u,2) * ax + 2 * u * t * newx + Math.pow(t,2) * nx1;
								var u1 = 1 - t;
								p[l2++] = Math.pow(u1,2) * ay + 2 * u1 * t * newy + Math.pow(t,2) * ny1;
								t += step;
							}
							p[l2++] = nx1;
							p[l2++] = ny1;
							var arr1 = _this.tempArr;
							var withMove = false;
							if(withMove == null) {
								withMove = true;
							}
							var l3 = arr1.length;
							var i3 = 2;
							if(withMove) {
								var x_ = arr1[0];
								var y_ = arr1[1];
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = x_;
								_this.y = y_;
								var l4 = _this.points.length;
								_this.points[l4] = [];
								_this.points[l4][0] = x_;
								_this.points[l4][1] = y_;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d1 = _this.dim[_this.dim.length - 1];
								if(x_ < d1.minX) {
									d1.minX = x_;
								}
								if(x_ > d1.maxX) {
									d1.maxX = x_;
								}
								if(y_ < d1.minY) {
									d1.minY = y_;
								}
								if(y_ > d1.maxY) {
									d1.maxY = y_;
								}
								_this.contour.reset();
							} else {
								_this.lineTo(arr1[0],arr1[1]);
							}
							var cx1 = (arr1[0] + arr1[l3 - 2]) / 2;
							var cy1 = (arr1[1] + arr1[l3 - 1]) / 2;
							var ox1 = _this.x;
							var oy1 = _this.y;
							while(i3 < l3) {
								if(_this.fill && _this.penIsDown) {
									if(i3 > 0 && i3 < l3 - 2) {
										_this.pen.triangle2DFill(arr1[i3 - 2],arr1[i3 - 1],arr1[i3],arr1[i3 + 1],cx1,cy1);
									}
								}
								_this.lineTo(arr1[i3],arr1[i3 + 1]);
								i3 += 2;
							}
							if(_this.fill && _this.penIsDown) {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = ox1;
								_this.y = oy1;
								var l5 = _this.points.length;
								_this.points[l5] = [];
								_this.points[l5][0] = ox1;
								_this.points[l5][1] = oy1;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d2 = _this.dim[_this.dim.length - 1];
								if(ox1 < d2.minX) {
									d2.minX = ox1;
								}
								if(ox1 > d2.maxX) {
									d2.maxX = ox1;
								}
								if(oy1 < d2.minY) {
									d2.minY = oy1;
								}
								if(oy1 > d2.maxY) {
									d2.maxY = oy1;
								}
								_this.contour.reset();
								_this.lineTo(arr1[l3 - 2],arr1[l3 - 1]);
							}
							_this.x = nx1;
							_this.y = ny1;
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx1;
							_this.y = ny1;
							var l6 = _this.points.length;
							_this.points[l6] = [];
							_this.points[l6][0] = nx1;
							_this.points[l6][1] = ny1;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d3 = _this.dim[_this.dim.length - 1];
							if(nx1 < d3.minX) {
								d3.minX = nx1;
							}
							if(nx1 > d3.maxX) {
								d3.maxX = nx1;
							}
							if(ny1 < d3.minY) {
								d3.minY = ny1;
							}
							if(ny1 > d3.maxY) {
								d3.maxY = ny1;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "ARC_SIDES":
					var radius2 = v[j];
					var degrees1 = v[j + 1];
					var sides = v[j + 2];
					if(sides == null) {
						sides = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides == 24) {
							_this.historyAdd("ARC");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
						} else {
							_this.historyAdd("ARC_SIDES");
							_this.historyParameters.push(radius2);
							_this.historyParameters.push(degrees1);
							_this.historyParameters.push(sides);
						}
					}
					if(radius2 != 0) {
						if(_this.repeatCommands) {
							if(sides == 24) {
								_this.turtleCommands.push("ARC");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
							} else {
								_this.turtleCommands.push("ARC_SIDES");
								_this.turtleParameters.push(radius2);
								_this.turtleParameters.push(degrees1);
								_this.turtleParameters.push(sides);
							}
						} else {
							var beta1 = degrees1 * Math.PI / 180 / sides;
							var alpha1 = (Math.PI - beta1) / 2;
							var rotate1 = -(Math.PI / 2 - alpha1);
							var baseLength1 = 0.5 * radius2 * Math.sin(beta1 / 2);
							var ox2 = _this.x;
							var oy2 = _this.y;
							var arr2 = [];
							arr2.push(_this.x);
							arr2.push(_this.y);
							var _g5 = 0;
							while(_g5 < 48) {
								var i4 = _g5++;
								_this.rotation += rotate1;
								var wasHistoryOn2 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength1);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength1);
								} else {
									var nx2 = _this.x + baseLength1 * Math.cos(_this.rotation);
									var ny2 = _this.y + baseLength1 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength1;
										_this.lineTo(nx2,ny2);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx2;
										_this.y = ny2;
										var l7 = _this.points.length;
										_this.points[l7] = [];
										_this.points[l7][0] = nx2;
										_this.points[l7][1] = ny2;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d4 = _this.dim[_this.dim.length - 1];
										if(nx2 < d4.minX) {
											d4.minX = nx2;
										}
										if(nx2 > d4.maxX) {
											d4.maxX = nx2;
										}
										if(ny2 < d4.minY) {
											d4.minY = ny2;
										}
										if(ny2 > d4.maxY) {
											d4.maxY = ny2;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn2;
								if(_this.fill) {
									arr2.push(_this.x);
									arr2.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx2 = (ox2 + arr2[arr2.length - 2]) / 2;
								var cy2 = (oy2 + arr2[arr2.length - 1]) / 2;
								var l8 = arr2.length;
								var i5 = 2;
								var lx1 = 0.;
								var ly1 = 0.;
								_this.pen.triangle2DFill(ox2,oy2,arr2[0],arr2[1],cx2,cy2);
								while(i5 < l8) {
									if(i5 > 2) {
										_this.pen.triangle2DFill(lx1,ly1,arr2[i5],arr2[i5 + 1],cx2,cy2);
									}
									lx1 = arr2[i5];
									ly1 = arr2[i5 + 1];
									i5 += 2;
								}
							}
							arr2.length = 0;
						}
					}
					j += 3;
					break;
				case "BACKWARD":
					var distance1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BACKWARD");
						_this.historyParameters.push(distance1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BACKWARD");
						_this.turtleParameters.push(distance1);
					} else {
						var nx3 = _this.x + distance1 * Math.cos(_this.rotation + Math.PI);
						var ny3 = _this.y + distance1 * Math.sin(_this.rotation + Math.PI);
						if(_this.penIsDown) {
							_this.lineTo(nx3,ny3);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx3;
							_this.y = ny3;
							var l9 = _this.points.length;
							_this.points[l9] = [];
							_this.points[l9][0] = nx3;
							_this.points[l9][1] = ny3;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d5 = _this.dim[_this.dim.length - 1];
							if(nx3 < d5.minX) {
								d5.minX = nx3;
							}
							if(nx3 > d5.maxX) {
								d5.maxX = nx3;
							}
							if(ny3 < d5.minY) {
								d5.minY = ny3;
							}
							if(ny3 > d5.maxY) {
								d5.maxY = ny3;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "BEGIN_REPEAT":
					break;
				case "BLACK":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLACK");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLACK");
					} else {
						_this.pen.currentColor = -16777216;
					}
					break;
				case "BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BLUE");
					} else {
						_this.pen.currentColor = -16776961;
					}
					break;
				case "BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("BROWN");
					} else {
						_this.pen.currentColor = -6594501;
					}
					break;
				case "CIRCLE":
					var radius3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CIRCLE");
						_this.historyParameters.push(radius3);
					}
					if(radius3 != 0) {
						if(_this.repeatCommands) {
							_this.turtleCommands.push("CIRCLE");
							_this.turtleParameters.push(radius3);
						} else {
							var beta2 = 2 * Math.PI / 24;
							var alpha2 = (Math.PI - beta2) / 2;
							var rotate2 = -(Math.PI / 2 - alpha2);
							var baseLength2 = 0.5 * radius3 * Math.sin(beta2 / 2);
							var ox3 = _this.x;
							var oy3 = _this.y;
							var arr3 = [];
							var _g6 = 0;
							while(_g6 < 48) {
								var i6 = _g6++;
								_this.rotation += rotate2;
								var wasHistoryOn3 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength2);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength2);
								} else {
									var nx4 = _this.x + baseLength2 * Math.cos(_this.rotation);
									var ny4 = _this.y + baseLength2 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength2;
										_this.lineTo(nx4,ny4);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx4;
										_this.y = ny4;
										var l10 = _this.points.length;
										_this.points[l10] = [];
										_this.points[l10][0] = nx4;
										_this.points[l10][1] = ny4;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d6 = _this.dim[_this.dim.length - 1];
										if(nx4 < d6.minX) {
											d6.minX = nx4;
										}
										if(nx4 > d6.maxX) {
											d6.maxX = nx4;
										}
										if(ny4 < d6.minY) {
											d6.minY = ny4;
										}
										if(ny4 > d6.maxY) {
											d6.maxY = ny4;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn3;
								if(_this.fill) {
									arr3.push(_this.x);
									arr3.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx3 = (ox3 + arr3[arr3.length - 2]) / 2;
								var cy3 = (oy3 + arr3[arr3.length - 1]) / 2;
								var l11 = arr3.length;
								var i7 = 2;
								var lx2 = 0.;
								var ly2 = 0.;
								while(i7 < l11) {
									if(i7 > 2) {
										_this.pen.triangle2DFill(lx2,ly2,arr3[i7],arr3[i7 + 1],cx3,cy3);
									}
									lx2 = arr3[i7];
									ly2 = arr3[i7 + 1];
									i7 += 2;
								}
							}
							arr3.length = 0;
						}
					}
					++j;
					break;
				case "CIRCLE_SIDES":
					var radius4 = v[j];
					var sides1 = v[j + 1];
					if(sides1 == null) {
						sides1 = 24;
					}
					if(_this.turtleHistoryOn) {
						if(sides1 == 24) {
							_this.historyAdd("CIRCLE");
							_this.historyParameters.push(radius4);
						} else {
							_this.historyAdd("CIRCLE_SIDES");
							_this.historyParameters.push(radius4);
							_this.historyParameters.push(sides1);
						}
					}
					if(radius4 != 0) {
						if(_this.repeatCommands) {
							if(sides1 == 24) {
								_this.turtleCommands.push("CIRCLE");
								_this.turtleParameters.push(radius4);
							} else {
								_this.turtleCommands.push("CIRCLE_SIDES");
								_this.turtleParameters.push(radius4);
								_this.turtleParameters.push(sides1);
							}
						} else {
							var beta3 = 2 * Math.PI / sides1;
							var alpha3 = (Math.PI - beta3) / 2;
							var rotate3 = -(Math.PI / 2 - alpha3);
							var baseLength3 = 0.5 * radius4 * Math.sin(beta3 / 2);
							var ox4 = _this.x;
							var oy4 = _this.y;
							var arr4 = [];
							var _g7 = 0;
							while(_g7 < 48) {
								var i8 = _g7++;
								_this.rotation += rotate3;
								var wasHistoryOn4 = _this.turtleHistoryOn;
								_this.turtleHistoryOn = false;
								if(_this.turtleHistoryOn) {
									_this.historyAdd("FORWARD");
									_this.historyParameters.push(baseLength3);
								}
								if(_this.repeatCommands) {
									_this.turtleCommands.push("FORWARD");
									_this.turtleParameters.push(baseLength3);
								} else {
									var nx5 = _this.x + baseLength3 * Math.cos(_this.rotation);
									var ny5 = _this.y + baseLength3 * Math.sin(_this.rotation);
									if(_this.penIsDown) {
										_this.lastDistance = baseLength3;
										_this.lineTo(nx5,ny5);
									} else {
										if(_this.endLine == 2 || _this.endLine == 3) {
											_this.contour.end(_this.width);
										}
										_this.x = nx5;
										_this.y = ny5;
										var l12 = _this.points.length;
										_this.points[l12] = [];
										_this.points[l12][0] = nx5;
										_this.points[l12][1] = ny5;
										_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
										_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
										_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
										var d7 = _this.dim[_this.dim.length - 1];
										if(nx5 < d7.minX) {
											d7.minX = nx5;
										}
										if(nx5 > d7.maxX) {
											d7.maxX = nx5;
										}
										if(ny5 < d7.minY) {
											d7.minY = ny5;
										}
										if(ny5 > d7.maxY) {
											d7.maxY = ny5;
										}
										_this.contour.reset();
									}
								}
								_this.turtleHistoryOn = wasHistoryOn4;
								if(_this.fill) {
									arr4.push(_this.x);
									arr4.push(_this.y);
								}
							}
							if(_this.fill) {
								var cx4 = (ox4 + arr4[arr4.length - 2]) / 2;
								var cy4 = (oy4 + arr4[arr4.length - 1]) / 2;
								var l13 = arr4.length;
								var i9 = 2;
								var lx3 = 0.;
								var ly3 = 0.;
								while(i9 < l13) {
									if(i9 > 2) {
										_this.pen.triangle2DFill(lx3,ly3,arr4[i9],arr4[i9 + 1],cx4,cy4);
									}
									lx3 = arr4[i9];
									ly3 = arr4[i9 + 1];
									i9 += 2;
								}
							}
							arr4.length = 0;
						}
					}
					j += 2;
					break;
				case "CYAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("CYAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("CYAN");
					} else {
						_this.pen.currentColor = -16711681;
					}
					break;
				case "DARKISH_BLUE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARKISH_BLUE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARKISH_BLUE");
					} else {
						_this.pen.currentColor = -8864837;
					}
					break;
				case "DARK_GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("DARK_GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("DARK_GREEN");
					} else {
						_this.pen.currentColor = -10182080;
					}
					break;
				case "EAST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("EAST");
					} else {
						_this.rotation = Math.PI;
					}
					break;
				case "END_REPEAT":
					break;
				case "FILL_OFF":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_OFF");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_OFF");
					} else {
						_this.fill = false;
					}
					break;
				case "FILL_ON":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FILL_ON");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FILL_ON");
					} else {
						_this.fill = true;
					}
					break;
				case "FORWARD":
					var distance3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD");
						_this.historyParameters.push(distance3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD");
						_this.turtleParameters.push(distance3);
					} else {
						var nx6 = _this.x + distance3 * Math.cos(_this.rotation);
						var ny6 = _this.y + distance3 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance3;
							_this.lineTo(nx6,ny6);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx6;
							_this.y = ny6;
							var l14 = _this.points.length;
							_this.points[l14] = [];
							_this.points[l14][0] = nx6;
							_this.points[l14][1] = ny6;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d8 = _this.dim[_this.dim.length - 1];
							if(nx6 < d8.minX) {
								d8.minX = nx6;
							}
							if(nx6 > d8.maxX) {
								d8.maxX = nx6;
							}
							if(ny6 < d8.minY) {
								d8.minY = ny6;
							}
							if(ny6 > d8.maxY) {
								d8.maxY = ny6;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_CHANGE":
					var deltaDistance = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_CHANGE");
						_this.historyParameters.push(deltaDistance);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_CHANGE");
						_this.turtleParameters.push(deltaDistance);
					} else {
						var distance4 = _this.lastDistance + deltaDistance;
						var nx7 = _this.x + distance4 * Math.cos(_this.rotation);
						var ny7 = _this.y + distance4 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance4 + deltaDistance;
							_this.lineTo(nx7,ny7);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx7;
							_this.y = ny7;
							var l15 = _this.points.length;
							_this.points[l15] = [];
							_this.points[l15][0] = nx7;
							_this.points[l15][1] = ny7;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d9 = _this.dim[_this.dim.length - 1];
							if(nx7 < d9.minX) {
								d9.minX = nx7;
							}
							if(nx7 > d9.maxX) {
								d9.maxX = nx7;
							}
							if(ny7 < d9.minY) {
								d9.minY = ny7;
							}
							if(ny7 > d9.maxY) {
								d9.maxY = ny7;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "FORWARD_FACTOR":
					var factor = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("FORWARD_FACTOR");
						_this.historyParameters.push(factor);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("FORWARD_FACTOR");
						_this.turtleParameters.push(factor);
					} else {
						var distance5 = _this.lastDistance * factor;
						var nx8 = _this.x + distance5 * Math.cos(_this.rotation);
						var ny8 = _this.y + distance5 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							_this.lastDistance = distance5;
							_this.lineTo(nx8,ny8);
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx8;
							_this.y = ny8;
							var l16 = _this.points.length;
							_this.points[l16] = [];
							_this.points[l16][0] = nx8;
							_this.points[l16][1] = ny8;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d10 = _this.dim[_this.dim.length - 1];
							if(nx8 < d10.minX) {
								d10.minX = nx8;
							}
							if(nx8 > d10.maxX) {
								d10.maxX = nx8;
							}
							if(ny8 < d10.minY) {
								d10.minY = ny8;
							}
							if(ny8 > d10.maxY) {
								d10.maxY = ny8;
							}
							_this.contour.reset();
						}
					}
					++j;
					break;
				case "GREEN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREEN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREEN");
					} else {
						_this.pen.currentColor = -16711936;
					}
					break;
				case "GREY":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("GREY");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("GREY");
					} else {
						_this.pen.currentColor = -4737097;
					}
					break;
				case "LEFT":
					var degrees2 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LEFT");
						_this.historyParameters.push(degrees2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LEFT");
						_this.turtleParameters.push(degrees2);
					} else {
						_this.rotation -= degrees2 * Math.PI / 180;
					}
					++j;
					break;
				case "LIGHT_BROWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("LIGHT_BROWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("LIGHT_BROWN");
					} else {
						_this.pen.currentColor = -3831790;
					}
					break;
				case "MAGENTA":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("MAGENTA");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MAGENTA");
					} else {
						_this.pen.currentColor = -65281;
					}
					break;
				case "MOVE_PEN":
					var distance6 = v[j];
					if(_this.repeatCommands) {
						_this.turtleCommands.push("MOVE_PEN");
						_this.turtleParameters.push(distance6);
					} else if(_this.penIsDown) {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_UP");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_UP");
						} else {
							_this.penIsDown = false;
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx9 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny9 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx9,ny9);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx9;
								_this.y = ny9;
								var l17 = _this.points.length;
								_this.points[l17] = [];
								_this.points[l17][0] = nx9;
								_this.points[l17][1] = ny9;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d11 = _this.dim[_this.dim.length - 1];
								if(nx9 < d11.minX) {
									d11.minX = nx9;
								}
								if(nx9 > d11.maxX) {
									d11.maxX = nx9;
								}
								if(ny9 < d11.minY) {
									d11.minY = ny9;
								}
								if(ny9 > d11.maxY) {
									d11.maxY = ny9;
								}
								_this.contour.reset();
							}
						}
						if(_this.turtleHistoryOn) {
							_this.historyAdd("PEN_DOWN");
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("PEN_DOWN");
						} else {
							_this.penIsDown = true;
						}
					} else {
						if(_this.turtleHistoryOn) {
							_this.historyAdd("FORWARD");
							_this.historyParameters.push(distance6);
						}
						if(_this.repeatCommands) {
							_this.turtleCommands.push("FORWARD");
							_this.turtleParameters.push(distance6);
						} else {
							var nx10 = _this.x + distance6 * Math.cos(_this.rotation);
							var ny10 = _this.y + distance6 * Math.sin(_this.rotation);
							if(_this.penIsDown) {
								_this.lastDistance = distance6;
								_this.lineTo(nx10,ny10);
							} else {
								if(_this.endLine == 2 || _this.endLine == 3) {
									_this.contour.end(_this.width);
								}
								_this.x = nx10;
								_this.y = ny10;
								var l18 = _this.points.length;
								_this.points[l18] = [];
								_this.points[l18][0] = nx10;
								_this.points[l18][1] = ny10;
								_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
								_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
								_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
								var d12 = _this.dim[_this.dim.length - 1];
								if(nx10 < d12.minX) {
									d12.minX = nx10;
								}
								if(nx10 > d12.maxX) {
									d12.maxX = nx10;
								}
								if(ny10 < d12.minY) {
									d12.minY = ny10;
								}
								if(ny10 > d12.maxY) {
									d12.maxY = ny10;
								}
								_this.contour.reset();
							}
						}
					}
					++j;
					break;
				case "NORTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("NORTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("NORTH");
					} else {
						_this.rotation = -Math.PI / 2;
					}
					break;
				case "ORANGE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("ORANGE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("ORANGE");
					} else {
						_this.pen.currentColor = -23808;
					}
					break;
				case "PEN_COLOR":
					var r = v[j];
					var g = v[j + 1];
					var b = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR");
						_this.historyParameters.push(r);
						_this.historyParameters.push(g);
						_this.historyParameters.push(b);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR");
						_this.turtleParameters.push(r);
						_this.turtleParameters.push(g);
						_this.turtleParameters.push(b);
					} else {
						_this.pen.currentColor = Math.round(255) << 24 | Math.round(r * 255) << 16 | Math.round(g * 255) << 8 | Math.round(b * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_B":
					var r1 = v[j];
					var g1 = v[j + 1];
					var b1 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_B");
						_this.historyParameters.push(r1);
						_this.historyParameters.push(g1);
						_this.historyParameters.push(b1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_B");
						_this.turtleParameters.push(r1);
						_this.turtleParameters.push(g1);
						_this.turtleParameters.push(b1);
					} else {
						_this.pen.colorB = Math.round(255) << 24 | Math.round(r1 * 255) << 16 | Math.round(g1 * 255) << 8 | Math.round(b1 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_C":
					var r2 = v[j];
					var g2 = v[j + 1];
					var b2 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_C");
						_this.historyParameters.push(r2);
						_this.historyParameters.push(g2);
						_this.historyParameters.push(b2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_C");
						_this.turtleParameters.push(r2);
						_this.turtleParameters.push(g2);
						_this.turtleParameters.push(b2);
					} else {
						_this.pen.colorC = Math.round(255) << 24 | Math.round(r2 * 255) << 16 | Math.round(g2 * 255) << 8 | Math.round(b2 * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE":
					var r3 = v[j];
					var g3 = v[j + 1];
					var b3 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE");
						_this.historyParameters.push(r3);
						_this.historyParameters.push(g3);
						_this.historyParameters.push(b3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE");
						_this.turtleParameters.push(r3);
						_this.turtleParameters.push(g3);
						_this.turtleParameters.push(b3);
					} else {
						var c = _this.pen.currentColor;
						var r0 = (c >> 16 & 255) / 255;
						var g0 = (c >> 8 & 255) / 255;
						var b0 = (c & 255) / 255;
						_this.pen.currentColor = Math.round(255) << 24 | Math.round((r0 + r3) * 255) << 16 | Math.round((g0 + g3) * 255) << 8 | Math.round((b0 + b3) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_B":
					var r4 = v[j];
					var g4 = v[j + 1];
					var b4 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_B");
						_this.historyParameters.push(r4);
						_this.historyParameters.push(g4);
						_this.historyParameters.push(b4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_B");
						_this.turtleParameters.push(r4);
						_this.turtleParameters.push(g4);
						_this.turtleParameters.push(b4);
					} else {
						var c1 = _this.pen.colorB;
						var r01 = (c1 >> 16 & 255) / 255;
						var g01 = (c1 >> 8 & 255) / 255;
						var b01 = (c1 & 255) / 255;
						_this.pen.colorB = Math.round(255) << 24 | Math.round((r01 + r4) * 255) << 16 | Math.round((g01 + g4) * 255) << 8 | Math.round((b01 + b4) * 255);
					}
					j += 3;
					break;
				case "PEN_COLOR_CHANGE_C":
					var r5 = v[j];
					var g5 = v[j + 1];
					var b5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_COLOR_CHANGE_C");
						_this.historyParameters.push(r5);
						_this.historyParameters.push(g5);
						_this.historyParameters.push(b5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_COLOR_CHANGE_C");
						_this.turtleParameters.push(r5);
						_this.turtleParameters.push(g5);
						_this.turtleParameters.push(b5);
					} else {
						var c2 = _this.pen.colorC;
						var r02 = (c2 >> 16 & 255) / 255;
						var g02 = (c2 >> 8 & 255) / 255;
						var b02 = (c2 & 255) / 255;
						_this.pen.colorC = Math.round(255) << 24 | Math.round((r02 + r5) * 255) << 16 | Math.round((g02 + g5) * 255) << 8 | Math.round((b02 + b5) * 255);
					}
					j += 3;
					break;
				case "PEN_DOWN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_DOWN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_DOWN");
					} else {
						_this.penIsDown = true;
					}
					break;
				case "PEN_SIZE":
					var w = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE");
						_this.historyParameters.push(w);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE");
						_this.turtleParameters.push(w);
					} else {
						_this.width = w;
					}
					++j;
					break;
				case "PEN_SIZE_CHANGE":
					var dw = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_CHANGE");
						_this.historyParameters.push(dw);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_CHANGE");
						_this.turtleParameters.push(dw);
					} else {
						_this.width += dw;
					}
					++j;
					break;
				case "PEN_SIZE_FACTOR":
					var factor1 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_SIZE_FACTOR");
						_this.historyParameters.push(factor1);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_SIZE_FACTOR");
						_this.turtleParameters.push(factor1);
					} else {
						_this.width *= factor1;
					}
					++j;
					break;
				case "PEN_UP":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PEN_UP");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PEN_UP");
					} else {
						_this.penIsDown = false;
					}
					break;
				case "PLUM":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("PLUM");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("PLUM");
					} else {
						_this.pen.currentColor = -7310896;
					}
					break;
				case "RED":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RED");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RED");
					} else {
						_this.pen.currentColor = -65536;
					}
					break;
				case "RIGHT":
					var degrees3 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("RIGHT");
						_this.historyParameters.push(degrees3);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("RIGHT");
						_this.turtleParameters.push(degrees3);
					} else {
						_this.rotation += degrees3 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_ANGLE":
					var degrees4 = v[j];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_ANGLE");
						_this.historyParameters.push(degrees4);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_ANGLE");
						_this.turtleParameters.push(degrees4);
					} else {
						_this.rotation = -Math.PI / 2;
						_this.rotation += degrees4 * Math.PI / 180;
					}
					++j;
					break;
				case "SET_POSITION":
					var x2 = v[j];
					var y2 = v[j + 1];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SET_POSITION");
						_this.historyParameters.push(x2);
						_this.historyParameters.push(y2);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SET_POSITION");
						_this.turtleParameters.push(x2);
						_this.turtleParameters.push(y2);
					} else {
						if(_this.endLine == 2 || _this.endLine == 3) {
							_this.contour.end(_this.width);
						}
						_this.x = x2;
						_this.y = y2;
						var l19 = _this.points.length;
						_this.points[l19] = [];
						_this.points[l19][0] = x2;
						_this.points[l19][1] = y2;
						_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
						_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
						_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
						var d13 = _this.dim[_this.dim.length - 1];
						if(x2 < d13.minX) {
							d13.minX = x2;
						}
						if(x2 > d13.maxX) {
							d13.maxX = x2;
						}
						if(y2 < d13.minY) {
							d13.minY = y2;
						}
						if(y2 > d13.maxY) {
							d13.maxY = y2;
						}
						_this.contour.reset();
					}
					j += 2;
					break;
				case "SOUTH":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("SOUTH");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("SOUTH");
					} else {
						_this.rotation = Math.PI / 2;
					}
					break;
				case "TAN":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TAN");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TAN");
					} else {
						_this.pen.currentColor = -27273;
					}
					break;
				case "TRIANGLE_ARCH":
					var distance7 = v[j];
					var distance21 = v[j + 1];
					var radius5 = v[j + 2];
					if(_this.turtleHistoryOn) {
						_this.historyAdd("TRIANGLE_ARCH");
						_this.historyParameters.push(distance7);
						_this.historyParameters.push(distance21);
						_this.historyParameters.push(radius5);
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("TRIANGLE_ARCH");
						_this.turtleParameters.push(distance7);
						_this.turtleParameters.push(distance21);
						_this.turtleParameters.push(radius5);
					} else {
						var nx11 = _this.x + distance7 * Math.cos(_this.rotation);
						var ny11 = _this.y + distance7 * Math.sin(_this.rotation);
						if(_this.penIsDown) {
							var thruX1 = _this.x + distance21 * Math.cos(_this.rotation) - radius5 * Math.cos(_this.rotation + Math.PI / 2);
							var thruY1 = _this.y + distance21 * Math.sin(_this.rotation) - radius5 * Math.sin(_this.rotation + Math.PI / 2);
							if(_this.fill) {
								_this.pen.triangle2DFill(_this.x,_this.y,thruX1,thruY1,nx11,ny11);
							}
							_this.lineTo(thruX1,thruY1);
							_this.lineTo(nx11,ny11);
							if(_this.fill) {
								_this.lineTo(_this.x,_this.y);
							}
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l20 = _this.points.length;
							_this.points[l20] = [];
							_this.points[l20][0] = nx11;
							_this.points[l20][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d14 = _this.dim[_this.dim.length - 1];
							if(nx11 < d14.minX) {
								d14.minX = nx11;
							}
							if(nx11 > d14.maxX) {
								d14.maxX = nx11;
							}
							if(ny11 < d14.minY) {
								d14.minY = ny11;
							}
							if(ny11 > d14.maxY) {
								d14.maxY = ny11;
							}
							_this.contour.reset();
						} else {
							if(_this.endLine == 2 || _this.endLine == 3) {
								_this.contour.end(_this.width);
							}
							_this.x = nx11;
							_this.y = ny11;
							var l21 = _this.points.length;
							_this.points[l21] = [];
							_this.points[l21][0] = nx11;
							_this.points[l21][1] = ny11;
							_this.pointsClock[_this.pointsClock.length] = _this.contour.pointsClock.slice();
							_this.pointsAnti[_this.pointsAnti.length] = _this.contour.pointsAnti.slice();
							_this.dim[_this.dim.length] = { minX : Infinity, maxX : -Infinity, minY : Infinity, maxY : -Infinity};
							var d15 = _this.dim[_this.dim.length - 1];
							if(nx11 < d15.minX) {
								d15.minX = nx11;
							}
							if(nx11 > d15.maxX) {
								d15.maxX = nx11;
							}
							if(ny11 < d15.minY) {
								d15.minY = ny11;
							}
							if(ny11 > d15.maxY) {
								d15.maxY = ny11;
							}
							_this.contour.reset();
						}
					}
					j += 3;
					break;
				case "WEST":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WEST");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WEST");
					} else {
						_this.rotation = 0;
					}
					break;
				case "WHITE":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("WHITE");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("WHITE");
					} else {
						_this.pen.currentColor = -1;
					}
					break;
				case "YELLOW":
					if(_this.turtleHistoryOn) {
						_this.historyAdd("YELLOW");
					}
					if(_this.repeatCommands) {
						_this.turtleCommands.push("YELLOW");
					} else {
						_this.pen.currentColor = -256;
					}
					break;
				}
			}
			j = 0;
		}
		_this.turtleHistoryOn = wasHistoryOn;
		_this.turtleCommands.length = 0;
		_this.turtleParameters.length = 0;
		var _this1 = _this;
		if(_this1.turtleHistoryOn) {
			_this1.historyAdd("BLUE");
		}
		if(_this1.repeatCommands) {
			_this1.turtleCommands.push("BLUE");
		} else {
			_this1.pen.currentColor = -16776961;
		}
		var range_min = s;
		var range_max = this.pen2D.arr[0] | 0;
		var tmp = this.allRange;
		var this1 = new cornerContour_io_IntIterStart(range_min,range_max);
		tmp.push(this1);
	}
	,setProgramMode: function() {
		this.gl.useProgram(this.programColor);
		var gl = this.gl;
		var program = this.programColor;
		var rgbaName = this.vertexColor;
		var inp = gl.getAttribLocation(program,this.vertexPosition);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 6 * elementBytes;
		var offBytes = 0 * elementBytes;
		gl.vertexAttribPointer(inp,2,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		var inp = gl.getAttribLocation(program,rgbaName);
		var elementBytes = 4;
		var fp = 5126;
		var strideBytes = 6 * elementBytes;
		var offBytes = 2 * elementBytes;
		gl.vertexAttribPointer(inp,4,fp,false,strideBytes,offBytes);
		gl.enableVertexAttribArray(inp);
		this.gl.bindBuffer(34962,this.bufColor);
	}
	,drawData: function(program,dataGL,start,end,triSize) {
		var partData = dataGL.subarray(start * triSize,end * triSize);
		this.gl.bufferSubData(34962,0,partData);
		this.gl.useProgram(program);
		this.gl.drawArrays(4,0,(end - start) * 3 | 0);
	}
};
function cornerContourWebGLTest_CornerContourWebGL2_main() {
	new cornerContourWebGLTest_CornerContourWebGL2();
}
var cornerContourWebGLTest_DivertTrace = function(left_) {
	if(left_ == null) {
		left_ = 610;
	}
	this.textStyle1 = "<span style=\"font-size:14px; color:Grey\">";
	this.textStyle0 = "<span style=\"font-size:12px; color:Silver\">";
	this.traceString = "";
	var doc = window.document;
	this.traceDiv = doc.createElement("div");
	doc.body.appendChild(this.traceDiv);
	var dom = this.traceDiv;
	var style = dom.style;
	style.position = "absolute";
	style.top = Std.string(0 + "px");
	style.left = Std.string(left_ + "px");
	style.height = Std.string(500 + "px");
	style.width = Std.string(500 + "px");
	style.zIndex = "99";
	style.overflow = "auto";
	haxe_Log.trace = $bind(this,this.myTrace);
	window.onerror = $bind(this,this.myError);
};
cornerContourWebGLTest_DivertTrace.__name__ = true;
cornerContourWebGLTest_DivertTrace.prototype = {
	myError: function(msg,url,lineNo,columnNo,errorObj) {
		var arr = url.split("/");
		var file = arr[arr.length - 2] + " " + arr[arr.length - 1];
		var str = this.textStyle0;
		str += "ERROR: " + file + " ( " + (lineNo == null ? "null" : "" + lineNo) + ": " + (columnNo == null ? "null" : "" + columnNo) + " )";
		str += "</span>";
		str += "<br> - ";
		str += this.textStyle1;
		str += Std.string(msg);
		str += "</span>";
		str += "<br>";
		this.traceString += str;
		this.traceDiv.innerHTML = this.traceString;
		return false;
	}
	,myTrace: function(v,inf) {
		if(Std.string(v) == "") {
			return;
		}
		this.traceString += this.textStyle0 + inf.className + "." + inf.methodName + " ( " + (inf.lineNumber == null ? "null" : "" + inf.lineNumber) + " )" + "</span>" + "<br> - " + this.textStyle1 + Std.string(v) + "</span>" + "<br>";
		this.traceDiv.innerHTML = this.traceString;
	}
};
var cornerContourWebGLTest_Sheet = function() {
};
cornerContourWebGLTest_Sheet.__name__ = true;
cornerContourWebGLTest_Sheet.prototype = {
	create: function(width_,height_,autoChild) {
		if(autoChild == null) {
			autoChild = false;
		}
		if(height_ == null) {
			height_ = 600;
		}
		if(width_ == null) {
			width_ = 600;
		}
		this.width = width_;
		this.height = height_;
		this.canvasGL = window.document.createElement("canvas");
		this.canvasGL.width = this.width;
		this.canvasGL.height = this.height;
		var body = window.document.body;
		body.style.overflow = "hidden";
		body.style.position = "fixed";
		this.pixelRatio = window.devicePixelRatio;
		if(this.pixelRatio == null) {
			this.pixelRatio = 1.;
		}
		var bodyEL = window.document.body;
		var style = bodyEL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		this.domGL = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvasGL);
		}
		this.canvas2D = window.document.createElement("canvas");
		this.canvas2D.width = this.width;
		this.canvas2D.height = this.height;
		this.domGL2D = this.canvasGL;
		var style = this.domGL.style;
		style.paddingLeft = Std.string(0 + "px");
		style.paddingTop = Std.string(0 + "px");
		style.left = Std.string(0 + "px");
		style.top = Std.string(0 + "px");
		style.marginLeft = Std.string(0 + "px");
		style.marginTop = Std.string(0 + "px");
		style.position = "absolute";
		if(autoChild) {
			body.appendChild(this.canvas2D);
		}
		this.gl = this.canvasGL.getContext("webgl",{ premultipliedAlpha : false});
		this.cx = this.canvas2D.getContext("2d");
	}
};
var fracs_DifferencePreference = $hxEnums["fracs.DifferencePreference"] = { __ename__:true,__constructs__:null
	,CLOCKWISE: {_hx_name:"CLOCKWISE",_hx_index:0,__enum__:"fracs.DifferencePreference",toString:$estr}
	,ANTICLOCKWISE: {_hx_name:"ANTICLOCKWISE",_hx_index:1,__enum__:"fracs.DifferencePreference",toString:$estr}
	,SMALL: {_hx_name:"SMALL",_hx_index:2,__enum__:"fracs.DifferencePreference",toString:$estr}
	,LARGE: {_hx_name:"LARGE",_hx_index:3,__enum__:"fracs.DifferencePreference",toString:$estr}
};
fracs_DifferencePreference.__constructs__ = [fracs_DifferencePreference.CLOCKWISE,fracs_DifferencePreference.ANTICLOCKWISE,fracs_DifferencePreference.SMALL,fracs_DifferencePreference.LARGE];
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = true;
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	get_native: function() {
		return this.__nativeException;
	}
});
var haxe_Log = function() { };
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
});
var haxe_ds_Either = $hxEnums["haxe.ds.Either"] = { __ename__:true,__constructs__:null
	,Left: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Left",$_.__params__ = ["v"],$_)
	,Right: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"haxe.ds.Either",toString:$estr}; },$_._hx_name="Right",$_.__params__ = ["v"],$_)
};
haxe_ds_Either.__constructs__ = [haxe_ds_Either.Left,haxe_ds_Either.Right];
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
};
var htmlHelper_tools_AnimateTimer = function() { };
htmlHelper_tools_AnimateTimer.__name__ = true;
htmlHelper_tools_AnimateTimer.loop = function(tim) {
	window.requestAnimationFrame(htmlHelper_tools_AnimateTimer.loop);
	if(htmlHelper_tools_AnimateTimer.onFrame != null) {
		htmlHelper_tools_AnimateTimer.onFrame(htmlHelper_tools_AnimateTimer.counter);
	}
	htmlHelper_tools_AnimateTimer.counter++;
	return true;
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var con = e.__constructs__[o._hx_index];
			var n = con._hx_name;
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
var cornerContour_CurveMath_quadStep = 0.03;
htmlHelper_tools_AnimateTimer.counter = 0;
cornerContourWebGLTest_CornerContourWebGL2_main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
